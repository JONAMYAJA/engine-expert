<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Game Background Designer</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }

      body {
        background-color: #f0f0f0;
        color: #333;
        overflow: hidden;
      }

      .container {
        display: flex;
        height: 100vh;
      }

      .sidebar {
        width: 300px;
        background-color: #2c3e50;
        color: #ecf0f1;
        padding: 20px;
        overflow-y: auto;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
      }

      .canvas-container {
        flex: 1;
        background-color: #222;
        position: relative;
      }

      #pixi-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      h2 {
        text-align: center;
        margin-bottom: 20px;
        color: #3498db;
        font-size: 1.6em;
      }

      h3 {
        margin: 10px 0;
        color: #2ecc71;
        border-bottom: 1px solid #34495e;
        padding-bottom: 5px;
      }

      .tool-section {
        margin-bottom: 20px;
        background-color: #34495e;
        padding: 15px;
        border-radius: 5px;
      }

      .tool-option {
        margin: 10px 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      label {
        margin-right: 10px;
        font-weight: 500;
      }

      input,
      select {
        padding: 5px;
        border-radius: 3px;
        border: none;
        background-color: #ecf0f1;
      }

      input[type="color"] {
        height: 30px;
        width: 60px;
      }

      input[type="range"] {
        width: 150px;
      }

      button {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
        width: 100%;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #2980b9;
      }

      #addShape,
      #addSprite,
      #downloadDesign {
        background-color: #2ecc71;
      }

      #addShape:hover,
      #addSprite:hover,
      #downloadDesign:hover {
        background-color: #27ae60;
      }

      #clearCanvas {
        background-color: #e74c3c;
      }

      #clearCanvas:hover {
        background-color: #c0392b;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="sidebar">
        <h2>Game Background Designer</h2>

        <div class="tool-section">
          <h3>Background</h3>
          <div class="tool-option">
            <label>Gradient Start:</label>
            <input type="color" id="gradientStart" value="#1a2980" />
          </div>
          <div class="tool-option">
            <label>Gradient End:</label>
            <input type="color" id="gradientEnd" value="#26d0ce" />
          </div>
          <div class="tool-option">
            <label>Gradient Direction:</label>
            <select id="gradientDirection">
              <option value="horizontal">Horizontal</option>
              <option value="vertical">Vertical</option>
              <option value="diagonal">Diagonal</option>
              <option value="radial">Radial</option>
            </select>
          </div>
          <button id="applyGradient">Apply Gradient</button>
        </div>

        <div class="tool-section">
          <h3>Background Image</h3>
          <div class="tool-option">
            <input type="file" id="backgroundImage" accept="image/*" />
          </div>
          <div class="tool-option">
            <label>Opacity:</label>
            <input
              type="range"
              id="imageOpacity"
              min="0"
              max="1"
              step="0.1"
              value="1"
            />
          </div>
          <button id="applyImage">Apply Image</button>
        </div>

        <div class="tool-section">
          <h3>Shapes</h3>
          <div class="tool-option">
            <label>Shape Type:</label>
            <select id="shapeType">
              <option value="circle">Circle</option>
              <option value="rectangle">Rectangle</option>
              <option value="polygon">Polygon</option>
              <option value="star">Star</option>
            </select>
          </div>
          <div class="tool-option">
            <label>Fill Color:</label>
            <input type="color" id="shapeFill" value="#ffffff" />
          </div>
          <div class="tool-option">
            <label>Outline Color:</label>
            <input type="color" id="shapeOutline" value="#000000" />
          </div>
          <div class="tool-option">
            <label>Outline Width:</label>
            <input type="range" id="outlineWidth" min="0" max="10" value="2" />
          </div>
          <button id="addShape">Add Shape</button>
        </div>

        <div class="tool-section">
          <h3>Sprites</h3>
          <div class="tool-option">
            <label>Sprite Library:</label>
            <select id="spriteLibrary">
              <option value="trees">Trees</option>
              <option value="clouds">Clouds</option>
              <option value="mountains">Mountains</option>
              <option value="buildings">Buildings</option>
              <option value="custom">Custom Sprite</option>
            </select>
          </div>
          <div id="customSpriteUpload" style="display: none">
            <input type="file" id="customSprite" accept="image/*" />
          </div>
          <button id="addSprite">Add Sprite</button>
        </div>

        <div class="tool-section">
          <h3>Actions</h3>
          <button id="clearCanvas">Clear Canvas</button>
          <button id="downloadDesign">Download Design</button>
        </div>
      </div>

      <div class="canvas-container">
        <div id="pixi-container"></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.2.4/dist/pixi.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.2.4/dist/pixi.min.js"></script>
    <script>
      // Initialize PIXI Application
      const app = new PIXI.Application({
        resizeTo: document.getElementById("pixi-container"),
        backgroundColor: 0x222222,
        antialias: true,
      });
      document.getElementById("pixi-container").appendChild(app.view);

      // Global variables
      const layers = {
        background: new PIXI.Container(),
        middle: new PIXI.Container(),
        foreground: new PIXI.Container(),
      };

      // Add layers to stage
      app.stage.addChild(layers.background);
      app.stage.addChild(layers.middle);
      app.stage.addChild(layers.foreground);

      let selectedObject = null;
      let isDragging = false;
      let dragData = null;
      let currentLayer = "middle";

      // Sprites library
      const spriteLibrary = {
        trees: [
          "https://pixijs.io/examples/examples/assets/bunny.png", // Placeholder URLs
          "https://pixijs.io/examples/examples/assets/bunny.png",
        ],
        clouds: [
          "https://pixijs.io/examples/examples/assets/bunny.png",
          "https://pixijs.io/examples/examples/assets/bunny.png",
        ],
        mountains: [
          "https://pixijs.io/examples/examples/assets/bunny.png",
          "https://pixijs.io/examples/examples/assets/bunny.png",
        ],
        buildings: [
          "https://pixijs.io/examples/examples/assets/bunny.png",
          "https://pixijs.io/examples/examples/assets/bunny.png",
        ],
      };

      // Functions
      function createGradientTexture(
        startColor,
        endColor,
        direction,
        width,
        height
      ) {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        let gradient;
        switch (direction) {
          case "horizontal":
            gradient = ctx.createLinearGradient(0, 0, width, 0);
            break;
          case "vertical":
            gradient = ctx.createLinearGradient(0, 0, 0, height);
            break;
          case "diagonal":
            gradient = ctx.createLinearGradient(0, 0, width, height);
            break;
          case "radial":
            gradient = ctx.createRadialGradient(
              width / 2,
              height / 2,
              0,
              width / 2,
              height / 2,
              Math.max(width, height) / 2
            );
            break;
          default:
            gradient = ctx.createLinearGradient(0, 0, 0, height);
        }
        gradient.addColorStop(0, startColor);
        gradient.addColorStop(1, endColor);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        return PIXI.Texture.from(canvas);
      }

      function applyGradientBackground() {
        const startColor = document.getElementById("gradientStart").value;
        const endColor = document.getElementById("gradientEnd").value;
        const direction = document.getElementById("gradientDirection").value;
        // Clear previous background
        while (layers.background.children.length > 0) {
          layers.background.removeChildAt(0);
        }
        // Create gradient background
        const texture = createGradientTexture(
          startColor,
          endColor,
          direction,
          app.renderer.width,
          app.renderer.height
        );
        const background = new PIXI.Sprite(texture);
        background.width = app.renderer.width;
        background.height = app.renderer.height;
        layers.background.addChild(background);
      }

      function applyBackgroundImage(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          // Create texture from uploaded image
          const texture = PIXI.Texture.from(e.target.result);
          // Remove any existing background image
          layers.background.children.forEach((child) => {
            if (child.isBackgroundImage) {
              layers.background.removeChild(child);
            }
          });
          // Create and add new background image
          const backgroundImage = new PIXI.Sprite(texture);
          backgroundImage.isBackgroundImage = true;
          // Fit image to screen while maintaining aspect ratio
          const scaleX = app.renderer.width / backgroundImage.width;
          const scaleY = app.renderer.height / backgroundImage.height;
          const scale = Math.max(scaleX, scaleY);
          backgroundImage.scale.set(scale);
          backgroundImage.position.set(
            (app.renderer.width - backgroundImage.width * scale) / 2,
            (app.renderer.height - backgroundImage.height * scale) / 2
          );
          // Set opacity
          const opacity = parseFloat(
            document.getElementById("imageOpacity").value
          );
          backgroundImage.alpha = opacity;
          // Add to background layer
          layers.background.addChild(backgroundImage);
        };
        reader.readAsDataURL(file);
      }

      function addShape() {
        const shapeType = document.getElementById("shapeType").value;
        const fillColor = parseInt(
          document.getElementById("shapeFill").value.replace("#", "0x")
        );
        const outlineColor = parseInt(
          document.getElementById("shapeOutline").value.replace("#", "0x")
        );
        const outlineWidth = parseInt(
          document.getElementById("outlineWidth").value
        );
        const shape = new PIXI.Graphics();
        shape.interactive = true;
        shape.cursor = "pointer";
        // Draw shape based on type
        shape.lineStyle(outlineWidth, outlineColor);
        shape.beginFill(fillColor);
        switch (shapeType) {
          case "circle":
            shape.drawCircle(0, 0, 50);
            break;
          case "rectangle":
            shape.drawRect(-50, -50, 100, 100);
            break;
          case "polygon":
            shape.drawPolygon([-50, -50, 50, -50, 25, 50, -25, 50]);
            break;
          case "star":
            const points = [];
            const outerRadius = 50;
            const innerRadius = 25;
            const numPoints = 5;
            for (let i = 0; i < numPoints * 2; i++) {
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              const angle = (i / numPoints) * Math.PI;
              points.push(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
            shape.drawPolygon(points);
            break;
        }
        shape.endFill();
        // Position in center of screen
        shape.position.set(app.renderer.width / 2, app.renderer.height / 2);
        // Add ability to drag
        shape
          .on("pointerdown", onDragStart)
          .on("pointerup", onDragEnd)
          .on("pointerupoutside", onDragEnd)
          .on("pointermove", onDragMove);
        layers[currentLayer].addChild(shape);
      }

      function addSprite() {
        const spriteOption = document.getElementById("spriteLibrary").value;
        let spriteUrl;
        if (spriteOption === "custom") {
          const fileInput = document.getElementById("customSprite");
          if (fileInput.files.length === 0) {
            alert("Please select a custom sprite file");
            return;
          }
          const reader = new FileReader();
          reader.onload = function (e) {
            createAndAddSprite(e.target.result);
          };
          reader.readAsDataURL(fileInput.files[0]);
        } else {
          // Get random sprite from the selected category
          const sprites = spriteLibrary[spriteOption];
          spriteUrl = sprites[Math.floor(Math.random() * sprites.length)];
          createAndAddSprite(spriteUrl);
        }
      }

      function createAndAddSprite(url) {
        const sprite = PIXI.Sprite.from(url);
        // Scale sprite down if too large
        if (sprite.width > app.renderer.width / 3) {
          sprite.scale.set(app.renderer.width / 3 / sprite.width);
        }
        // Position in center of screen
        sprite.anchor.set(0.5);
        sprite.position.set(app.renderer.width / 2, app.renderer.height / 2);
        // Make interactive
        sprite.interactive = true;
        sprite.cursor = "pointer";
        // Add drag functionality
        sprite
          .on("pointerdown", onDragStart)
          .on("pointerup", onDragEnd)
          .on("pointerupoutside", onDragEnd)
          .on("pointermove", onDragMove);
        layers[currentLayer].addChild(sprite);
      }

      // Drag functionality
      function onDragStart(event) {
        selectedObject = this;
        isDragging = true;
        dragData = event.data;
        this.alpha = 0.8;
      }

      function onDragEnd() {
        this.alpha = 1;
        isDragging = false;
        dragData = null;
      }

      function onDragMove() {
        if (isDragging) {
          const newPosition = dragData.getLocalPosition(this.parent);
          this.position.x = newPosition.x;
          this.position.y = newPosition.y;
        }
      }

      function clearCanvas() {
        // Clear all layers except background
        for (const layer in layers) {
          if (layer !== "background") {
            while (layers[layer].children.length > 0) {
              layers[layer].removeChildAt(0);
            }
          }
        }
      }

      function downloadDesign() {
        // Render the PIXI application to a data URL
        const dataURL = app.renderer.extract
          .canvas(app.stage)
          .toDataURL("image/png");
        // Create a download link
        const link = document.createElement("a");
        link.download = "game_background.png";
        link.href = dataURL;
        link.click();
      }

      // Add these new features - THIS IS WHERE YOU ADD THE NEW CODE
      // Add layer management functionality
      function setupLayerManagement() {
        // Create layer controls in sidebar
        const layerSection = document.createElement("div");
        layerSection.className = "tool-section";
        layerSection.innerHTML = `
        <h3>Layers</h3>
        <div class="tool-option">
            <label>Active Layer:</label>
            <select id="layerSelector">
                <option value="background">Background</option>
                <option value="middle" selected>Middle</option>
                <option value="foreground">Foreground</option>
            </select>
        </div>
        <div class="tool-option">
            <label>Layer Opacity:</label>
            <input type="range" id="layerOpacity" min="0" max="1" step="0.1" value="1">
        </div>
        <button id="addLayer">Add New Layer</button>
    `;

        // Insert after shapes section
        const shapesSection = document.querySelector(
          ".tool-section:nth-child(3)"
        );
        shapesSection.parentNode.insertBefore(
          layerSection,
          shapesSection.nextSibling
        );

        // Set up event listeners
        document
          .getElementById("layerSelector")
          .addEventListener("change", (e) => {
            currentLayer = e.target.value;
          });

        document
          .getElementById("layerOpacity")
          .addEventListener("input", (e) => {
            layers[currentLayer].alpha = parseFloat(e.target.value);
          });

        document.getElementById("addLayer").addEventListener("click", () => {
          const layerName = "custom" + Object.keys(layers).length;
          layers[layerName] = new PIXI.Container();
          app.stage.addChild(layers[layerName]);

          // Add to selector
          const option = document.createElement("option");
          option.value = layerName;
          option.textContent = "Custom " + (Object.keys(layers).length - 3);
          document.getElementById("layerSelector").appendChild(option);
          document.getElementById("layerSelector").value = layerName;
          currentLayer = layerName;
        });
      }

      // Add particle effects
      function setupParticleEffects() {
        const particleSection = document.createElement("div");
        particleSection.className = "tool-section";
        particleSection.innerHTML = `
        <h3>Particle Effects</h3>
        <div class="tool-option">
            <label>Effect Type:</label>
            <select id="effectType">
                <option value="sparkle">Sparkles</option>
                <option value="snow">Snow</option>
                <option value="rain">Rain</option>
                <option value="bubbles">Bubbles</option>
                <option value="fire">Fire</option>
            </select>
        </div>
        <div class="tool-option">
            <label>Particle Color:</label>
            <input type="color" id="particleColor" value="#ffffff">
        </div>
        <div class="tool-option">
            <label>Intensity:</label>
            <input type="range" id="particleIntensity" min="1" max="100" value="50">
        </div>
        <button id="addEffect">Add Effect</button>
    `;

        // Add to sidebar
        document
          .querySelector(".sidebar")
          .insertBefore(
            particleSection,
            document.querySelector(".tool-section:last-child")
          );

        // Set up particles
        const particles = {};

        document.getElementById("addEffect").addEventListener("click", () => {
          const effectType = document.getElementById("effectType").value;
          const color = parseInt(
            document.getElementById("particleColor").value.replace("#", "0x"),
            16
          );
          const intensity = parseInt(
            document.getElementById("particleIntensity").value
          );

          // Create particle container
          const particleContainer = new PIXI.ParticleContainer(intensity * 10, {
            position: true,
            rotation: true,
            uvs: true,
            alpha: true,
          });

          layers[currentLayer].addChild(particleContainer);

          // Create effect based on type
          const effectId = effectType + Date.now();
          particles[effectId] = {
            container: particleContainer,
            particles: [],
            type: effectType,
            intensity: intensity,
          };

          // Create initial particles
          for (let i = 0; i < intensity; i++) {
            createParticle(particles[effectId], color);
          }

          // Add update function to app ticker
          app.ticker.add(() => updateParticles(particles[effectId], color));
        });
      }

      function createParticle(effectObj, color) {
        const particle = new PIXI.Graphics();

        switch (effectObj.type) {
          case "sparkle":
            particle.beginFill(color);
            particle.drawStar(
              0,
              0,
              5,
              2 + Math.random() * 3,
              Math.random() * 5
            );
            particle.endFill();
            particle.x = Math.random() * app.renderer.width;
            particle.y = Math.random() * app.renderer.height;
            particle.alpha = Math.random();
            particle.scale.set(0.1 + Math.random() * 0.3);
            particle.rotation = Math.random() * Math.PI * 2;
            particle.speedX = (Math.random() - 0.5) * 0.5;
            particle.speedY = (Math.random() - 0.5) * 0.5;
            particle.speedRotation = (Math.random() - 0.5) * 0.1;
            particle.speedAlpha = -0.01 + Math.random() * 0.02;
            break;

          case "snow":
            particle.beginFill(color);
            particle.drawCircle(0, 0, 1 + Math.random() * 3);
            particle.endFill();
            particle.x = Math.random() * app.renderer.width;
            particle.y = -10;
            particle.speedX = (Math.random() - 0.5) * 1;
            particle.speedY = 0.5 + Math.random() * 2;
            particle.speedRotation = (Math.random() - 0.5) * 0.1;
            break;

          case "rain":
            particle.beginFill(color);
            particle.drawRect(0, 0, 1, 10 + Math.random() * 10);
            particle.endFill();
            particle.x = Math.random() * app.renderer.width;
            particle.y = -30;
            particle.rotation = Math.PI / 6;
            particle.speedX = 3 + Math.random() * 2;
            particle.speedY = 10 + Math.random() * 10;
            break;

          case "bubbles":
            particle.beginFill(color, 0.4);
            particle.lineStyle(1, color, 0.8);
            particle.drawCircle(0, 0, 3 + Math.random() * 7);
            particle.endFill();
            particle.x = Math.random() * app.renderer.width;
            particle.y = app.renderer.height + 10;
            particle.speedX = (Math.random() - 0.5) * 1;
            particle.speedY = -(1 + Math.random() * 3);
            break;

          case "fire":
            particle.beginFill(Math.random() > 0.5 ? color : 0xff3300);
            particle.drawCircle(0, 0, 5 + Math.random() * 5);
            particle.endFill();
            particle.x = app.renderer.width / 2 + (Math.random() - 0.5) * 100;
            particle.y = app.renderer.height - 20;
            particle.speedX = (Math.random() - 0.5) * 2;
            particle.speedY = -(2 + Math.random() * 5);
            particle.speedScale = -0.01;
            particle.speedAlpha = -0.01;
            break;
        }

        effectObj.container.addChild(particle);
        effectObj.particles.push(particle);

        return particle;
      }

      function updateParticles(effectObj, color) {
        for (let i = effectObj.particles.length - 1; i >= 0; i--) {
          const p = effectObj.particles[i];

          // Update position
          p.x += p.speedX || 0;
          p.y += p.speedY || 0;

          // Update rotation if defined
          if (p.speedRotation) {
            p.rotation += p.speedRotation;
          }

          // Update alpha if defined
          if (p.speedAlpha) {
            p.alpha += p.speedAlpha;
            if (p.alpha <= 0) {
              effectObj.container.removeChild(p);
              effectObj.particles.splice(i, 1);
              createParticle(effectObj, color);
              continue;
            }
          }

          // Update scale if defined
          if (p.speedScale) {
            p.scale.x += p.speedScale;
            p.scale.y += p.speedScale;
            if (p.scale.x <= 0) {
              effectObj.container.removeChild(p);
              effectObj.particles.splice(i, 1);
              createParticle(effectObj, color);
              continue;
            }
          }

          // Check if particle is out of bounds
          if (
            p.y < -20 ||
            p.y > app.renderer.height + 20 ||
            p.x < -20 ||
            p.x > app.renderer.width + 20
          ) {
            effectObj.container.removeChild(p);
            effectObj.particles.splice(i, 1);
            createParticle(effectObj, color);
          }
        }
      }

      // Add text elements
      function setupTextTools() {
        const textSection = document.createElement("div");
        textSection.className = "tool-section";
        textSection.innerHTML = `
        <h3>Text</h3>
        <div class="tool-option">
            <label>Text Content:</label>
            <input type="text" id="textContent" value="Game Title">
        </div>
        <div class="tool-option">
            <label>Font Size:</label>
            <input type="range" id="fontSize" min="10" max="100" value="40">
        </div>
        <div class="tool-option">
            <label>Text Color:</label>
            <input type="color" id="textColor" value="#ffffff">
        </div>
        <div class="tool-option">
            <label>Font:</label>
            <select id="fontFamily">
                <option value="Arial">Arial</option>
                <option value="Verdana">Verdana</option>
                <option value="Courier New">Courier New</option>
                <option value="Impact">Impact</option>
                <option value="Comic Sans MS">Comic Sans MS</option>
            </select>
        </div>
        <div class="tool-option">
            <label>Glow Effect:</label>
            <input type="checkbox" id="textGlow">
        </div>
        <button id="addText">Add Text</button>
    `;

        // Add to sidebar
        document
          .querySelector(".sidebar")
          .insertBefore(
            textSection,
            document.querySelector(".tool-section:last-child")
          );

        // Set up event listener
        document.getElementById("addText").addEventListener("click", () => {
          const content = document.getElementById("textContent").value;
          const fontSize = document.getElementById("fontSize").value;
          const color = document.getElementById("textColor").value;
          const fontFamily = document.getElementById("fontFamily").value;
          const glow = document.getElementById("textGlow").checked;

          const style = new PIXI.TextStyle({
            fontFamily: fontFamily,
            fontSize: fontSize,
            fill: color,
            fontWeight: "bold",
          });

          if (glow) {
            style.dropShadow = true;
            style.dropShadowColor = color;
            style.dropShadowBlur = 15;
            style.dropShadowDistance = 0;
          }

          const text = new PIXI.Text(content, style);
          text.anchor.set(0.5);
          text.position.set(app.renderer.width / 2, app.renderer.height / 2);

          // Make interactive
          text.interactive = true;
          text.cursor = "pointer";
          text
            .on("pointerdown", onDragStart)
            .on("pointerup", onDragEnd)
            .on("pointerupoutside", onDragEnd)
            .on("pointermove", onDragMove);

          layers[currentLayer].addChild(text);
        });
      }

      // Setup filters and effects
      function setupFilters() {
        const filterSection = document.createElement("div");
        filterSection.className = "tool-section";
        filterSection.innerHTML = `
        <h3>Filters & Effects</h3>
        <div class="tool-option">
            <label>Blur:</label>
            <input type="range" id="blurEffect" min="0" max="20" value="0">
        </div>
        <div class="tool-option">
            <label>Brightness:</label>
            <input type="range" id="brightnessEffect" min="0" max="2" step="0.1" value="1">
        </div>
        <div class="tool-option">
            <label>Contrast:</label>
            <input type="range" id="contrastEffect" min="0" max="2" step="0.1" value="1">
        </div>
        <div class="tool-option">
            <label>Hue Shift:</label>
            <input type="range" id="hueEffect" min="0" max="360" value="0">
        </div>
        <div class="tool-option">
            <label>Pixelate:</label>
            <input type="range" id="pixelateEffect" min="1" max="20" value="1">
        </div>
        <button id="applyFilters">Apply to Layer</button>
    `;

        // Add to sidebar
        document
          .querySelector(".sidebar")
          .insertBefore(
            filterSection,
            document.querySelector(".tool-section:last-child")
          );

        // Set up filters object
        const filters = {
          blur: new PIXI.filters.BlurFilter(),
          colorMatrix: new PIXI.filters.ColorMatrixFilter(),
          pixelate: new PIXI.filters.PixelateFilter(),
        };

        filters.blur.blendMode = PIXI.BLEND_MODES.NORMAL;

        // Set up event listener
        document
          .getElementById("applyFilters")
          .addEventListener("click", () => {
            // Get values
            const blurValue = parseInt(
              document.getElementById("blurEffect").value
            );
            const brightnessValue = parseFloat(
              document.getElementById("brightnessEffect").value
            );
            const contrastValue = parseFloat(
              document.getElementById("contrastEffect").value
            );
            const hueValue = parseInt(
              document.getElementById("hueEffect").value
            );
            const pixelateValue = parseInt(
              document.getElementById("pixelateEffect").value
            );

            // Configure filters
            filters.blur.blur = blurValue;
            filters.colorMatrix.reset();

            if (brightnessValue !== 1)
              filters.colorMatrix.brightness(brightnessValue, false);
            if (contrastValue !== 1)
              filters.colorMatrix.contrast(contrastValue, false);
            if (hueValue !== 0) filters.colorMatrix.hue(hueValue, false);

            filters.pixelate.size = pixelateValue;

            // Apply filters to current layer
            const activeFilters = [];
            if (blurValue > 0) activeFilters.push(filters.blur);
            if (
              brightnessValue !== 1 ||
              contrastValue !== 1 ||
              hueValue !== 0
            ) {
              activeFilters.push(filters.colorMatrix);
            }
            if (pixelateValue > 1) activeFilters.push(filters.pixelate);

            layers[currentLayer].filters =
              activeFilters.length > 0 ? activeFilters : null;
          });
      }

      // Add animation capabilities
      function setupAnimations() {
        const animationSection = document.createElement("div");
        animationSection.className = "tool-section";
        animationSection.innerHTML = `
        <h3>Animation</h3>
        <div class="tool-option">
            <label>Animation Type:</label>
            <select id="animationType">
                <option value="float">Float</option>
                <option value="pulse">Pulse</option>
                <option value="rotate">Rotate</option>
                <option value="shake">Shake</option>
            </select>
        </div>
        <div class="tool-option">
            <label>Duration (s):</label>
            <input type="number" id="animationDuration" min="0.5" max="10" step="0.5" value="2">
        </div>
        <div class="tool-option">
            <label>Intensity:</label>
            <input type="range" id="animationIntensity" min="1" max="100" value="50">
        </div>
        <button id="animateLastObject">Animate Last Object</button>
        <button id="animateBackground">Animate Background</button>
    `;

        // Add to sidebar
        document
          .querySelector(".sidebar")
          .insertBefore(
            animationSection,
            document.querySelector(".tool-section:last-child")
          );

        // Animation tracking
        const animations = [];

        // Animation functions
        function createAnimation(target, type, duration, intensity) {
          const fps = 60;
          const totalFrames = fps * duration;
          let currentFrame = 0;
          const normalizedIntensity = intensity / 100;

          // Save original properties for resetting
          const originalProps = {
            x: target.x,
            y: target.y,
            scaleX: target.scale.x,
            scaleY: target.scale.y,
            rotation: target.rotation,
            alpha: target.alpha,
          };

          const animation = {
            target: target,
            active: true,
            update: function () {
              if (!this.active) return;

              const progress = currentFrame / totalFrames;
              const wave = Math.sin(progress * Math.PI * 2);

              switch (type) {
                case "float":
                  target.y = originalProps.y + wave * 20 * normalizedIntensity;
                  break;
                case "pulse":
                  const scale = 1 + wave * 0.2 * normalizedIntensity;
                  target.scale.set(
                    originalProps.scaleX * scale,
                    originalProps.scaleY * scale
                  );
                  break;
                case "rotate":
                  target.rotation =
                    originalProps.rotation +
                    progress * Math.PI * 2 * normalizedIntensity;
                  break;
                case "shake":
                  if (Math.random() > 0.7) {
                    target.x =
                      originalProps.x +
                      (Math.random() - 0.5) * 10 * normalizedIntensity;
                    target.y =
                      originalProps.y +
                      (Math.random() - 0.5) * 10 * normalizedIntensity;
                  } else {
                    target.x = originalProps.x;
                    target.y = originalProps.y;
                  }
                  break;
              }

              currentFrame = (currentFrame + 1) % totalFrames;
            },
            stop: function () {
              this.active = false;
              target.x = originalProps.x;
              target.y = originalProps.y;
              target.scale.x = originalProps.scaleX;
              target.scale.y = originalProps.scaleY;
              target.rotation = originalProps.rotation;
            },
          };

          animations.push(animation);
          return animation;
        }

        // Add animation ticker
        app.ticker.add(() => {
          for (let i = animations.length - 1; i >= 0; i--) {
            if (animations[i].active) {
              animations[i].update();
            } else {
              animations.splice(i, 1);
            }
          }
        });

        // Event listeners
        document
          .getElementById("animateLastObject")
          .addEventListener("click", () => {
            const layer = layers[currentLayer];
            if (layer.children.length === 0) {
              alert("No objects to animate in the current layer");
              return;
            }

            const lastObject = layer.children[layer.children.length - 1];
            const type = document.getElementById("animationType").value;
            const duration = parseFloat(
              document.getElementById("animationDuration").value
            );
            const intensity = parseInt(
              document.getElementById("animationIntensity").value
            );

            createAnimation(lastObject, type, duration, intensity);
          });
        document
          .getElementById("animateBackground")
          .addEventListener("click", () => {
            const bg = layers.background.children[0];
            if (!bg) {
              alert("No background to animate");
              return;
            }
            const type = document.getElementById("animationType").value;
            const duration = parseFloat(
              document.getElementById("animationDuration").value
            );
            const intensity = parseInt(
              document.getElementById("animationIntensity").value
            );

            createAnimation(bg, type, duration, intensity);
          });
      }

      // Event listeners
      document.getElementById("applyGradient").addEventListener("click", () => {
        applyGradientBackground();
      });

      document.getElementById("applyImage").addEventListener("click", () => {
        const file = document.getElementById("backgroundImage").files[0];
        applyBackgroundImage(file);
      });

      document.getElementById("addShape").addEventListener("click", () => {
        addShape();
      });

      document.getElementById("addSprite").addEventListener("click", () => {
        addSprite();
      });

      document.getElementById("clearCanvas").addEventListener("click", () => {
        clearCanvas();
      });

      document
        .getElementById("downloadDesign")
        .addEventListener("click", () => {
          downloadDesign();
        });

      document
        .getElementById("spriteLibrary")
        .addEventListener("change", (e) => {
          const customUpload = document.getElementById("customSpriteUpload");
          customUpload.style.display =
            e.target.value === "custom" ? "block" : "none";
        });

      // Initialize with a gradient background on load
      window.addEventListener("load", () => {
        // Original initialization code
        applyGradientBackground();

        // Set up new features
        setupLayerManagement();
        setupParticleEffects();
        setupTextTools();
        setupFilters();
        setupAnimations();

        // Add one more tool - Presets
        const presetSection = document.createElement("div");
        presetSection.className = "tool-section";
        presetSection.innerHTML = `
        <h3>Presets</h3>
        <div class="preset-buttons">
            <button id="presetForest">Forest Scene</button>
            <button id="presetSpace">Space Scene</button>
            <button id="presetUnderwater">Underwater</button>
            <button id="presetDesert">Desert Scene</button>
            <button id="presetNightCity">Night City</button>
        </div>
    `;

        document
          .querySelector(".sidebar")
          .insertBefore(
            presetSection,
            document.querySelector(".tool-section:last-child")
          );

        // Implementation for preset buttons
        document
          .getElementById("presetForest")
          .addEventListener("click", () => {
            // Apply green gradient background
            document.getElementById("gradientStart").value = "#134e5e";
            document.getElementById("gradientEnd").value = "#71b280";
            document.getElementById("gradientDirection").value = "vertical";
            applyGradientBackground();

            // Add some trees
            currentLayer = "middle";
            for (let i = 0; i < 5; i++) {
              addSprite();
            }

            // Add particle effect
            document.getElementById("effectType").value = "sparkle";
            document.getElementById("particleColor").value = "#FFFF99";
            document.getElementById("particleIntensity").value = "30";
            document.getElementById("addEffect").click();
          });

        document.getElementById("presetSpace").addEventListener("click", () => {
          // Apply deep space gradient
          document.getElementById("gradientStart").value = "#000000";
          document.getElementById("gradientEnd").value = "#434343";
          document.getElementById("gradientDirection").value = "radial";
          applyGradientBackground();

          // Add stars
          currentLayer = "middle";
          for (let i = 0; i < 100; i++) {
            const star = new PIXI.Graphics();
            star.beginFill(0xffffff);
            star.drawCircle(0, 0, 1 + Math.random() * 2);
            star.endFill();
            star.position.set(
              Math.random() * app.renderer.width,
              Math.random() * app.renderer.height
            );
            star.alpha = 0.5 + Math.random() * 0.5;
            layers[currentLayer].addChild(star);
          }

          // Add nebula effect as a shape
          const nebula = new PIXI.Graphics();
          nebula.beginFill(0x9933ff, 0.15);
          nebula.drawEllipse(
            app.renderer.width / 2,
            app.renderer.height / 2,
            app.renderer.width / 3,
            app.renderer.height / 3
          );
          nebula.endFill();
          layers[currentLayer].addChild(nebula);

          // Apply filters to add glow
          document.getElementById("blurEffect").value = "8";
          document.getElementById("brightnessEffect").value = "1.2";
          document.getElementById("applyFilters").click();
        });

        document
          .getElementById("presetUnderwater")
          .addEventListener("click", () => {
            // Apply underwater gradient
            document.getElementById("gradientStart").value = "#1A2980";
            document.getElementById("gradientEnd").value = "#26D0CE";
            document.getElementById("gradientDirection").value = "vertical";
            applyGradientBackground();

            // Add bubbles effect
            document.getElementById("effectType").value = "bubbles";
            document.getElementById("particleColor").value = "#FFFFFF";
            document.getElementById("particleIntensity").value = "40";
            document.getElementById("addEffect").click();

            // Add some water plants
            currentLayer = "foreground";
            const plant = new PIXI.Graphics();
            plant.beginFill(0x006600);
            plant.drawRect(-5, 0, 10, 100);
            plant.endFill();
            plant.position.set(
              app.renderer.width / 4,
              app.renderer.height - 50
            );
            layers[currentLayer].addChild(plant);

            const plant2 = new PIXI.Graphics();
            plant2.beginFill(0x006600);
            plant2.drawRect(-5, 0, 10, 150);
            plant2.endFill();
            plant2.position.set(
              app.renderer.width / 1.5,
              app.renderer.height - 50
            );
            layers[currentLayer].addChild(plant2);

            // Animate plants
            createAnimation(plant, "float", 3, 30);
            createAnimation(plant2, "float", 4, 20);

            // Apply underwater filter
            document.getElementById("blurEffect").value = "2";
            document.getElementById("brightnessEffect").value = "0.9";
            document.getElementById("hueEffect").value = "180";
            document.getElementById("applyFilters").click();
          });

        document
          .getElementById("presetDesert")
          .addEventListener("click", () => {
            // Apply desert gradient
            document.getElementById("gradientStart").value = "#FF8008";
            document.getElementById("gradientEnd").value = "#FFC837";
            document.getElementById("gradientDirection").value = "vertical";
            applyGradientBackground();

            // Add sand dunes
            currentLayer = "middle";
            for (let i = 0; i < 3; i++) {
              const dune = new PIXI.Graphics();
              dune.beginFill(0xf7c462);

              // Draw curved dune shape
              dune.moveTo(0, 50 + i * 20);
              dune.bezierCurveTo(
                app.renderer.width / 3,
                -50 - i * 10,
                (app.renderer.width * 2) / 3,
                -50 - i * 10,
                app.renderer.width,
                50 + i * 20
              );
              dune.lineTo(app.renderer.width, app.renderer.height);
              dune.lineTo(0, app.renderer.height);
              dune.closePath();

              dune.endFill();
              dune.alpha = 0.7;
              dune.position.set(0, app.renderer.height - 100 - i * 50);
              layers[currentLayer].addChild(dune);
            }

            // Add a cactus
            const cactus = new PIXI.Graphics();
            cactus.beginFill(0x006400);
            cactus.drawRect(-10, -50, 20, 100);
            cactus.drawRect(-30, -40, 20, 15);
            cactus.drawRect(10, -30, 20, 15);
            cactus.endFill();
            cactus.position.set(
              app.renderer.width * 0.7,
              app.renderer.height - 100
            );
            layers[currentLayer].addChild(cactus);

            // Apply desert heat effect
            document.getElementById("blurEffect").value = "1";
            document.getElementById("brightnessEffect").value = "1.2";
            document.getElementById("contrastEffect").value = "1.1";
            document.getElementById("applyFilters").click();
          });

        document
          .getElementById("presetNightCity")
          .addEventListener("click", () => {
            // Apply night city gradient
            document.getElementById("gradientStart").value = "#0F2027";
            document.getElementById("gradientEnd").value = "#2C5364";
            document.getElementById("gradientDirection").value = "vertical";
            applyGradientBackground();

            // Add city skyline
            currentLayer = "middle";

            // Create skyline with multiple buildings
            for (let i = 0; i < 15; i++) {
              const building = new PIXI.Graphics();
              building.beginFill(0x000000);

              const height = 100 + Math.random() * 200;
              const width = 30 + Math.random() * 70;

              building.drawRect(0, 0, width, height);

              // Add windows
              building.beginFill(0xffff99, 0.8);
              for (let w = 5; w < width - 10; w += 12) {
                for (let h = 5; h < height - 10; h += 15) {
                  if (Math.random() > 0.3) {
                    // Some windows are dark
                    building.drawRect(w, h, 7, 10);
                  }
                }
              }

              building.endFill();
              building.position.set(i * 60, app.renderer.height - height);
              layers[currentLayer].addChild(building);
            }

            // Add moon
            const moon = new PIXI.Graphics();
            moon.beginFill(0xffffcc);
            moon.drawCircle(0, 0, 40);
            moon.endFill();
            moon.position.set(
              app.renderer.width * 0.8,
              app.renderer.height * 0.2
            );
            layers["background"].addChild(moon);

            // Add text with glow effect
            document.getElementById("textContent").value = "NIGHT CITY";
            document.getElementById("fontSize").value = "60";
            document.getElementById("textColor").value = "#4FC3F7";
            document.getElementById("textGlow").checked = true;
            document.getElementById("addText").click();

            // Apply night effect
            document.getElementById("contrastEffect").value = "1.2";
            document.getElementById("blurEffect").value = "2";
            document.getElementById("applyFilters").click();
          });

        // Add more advanced tools - 3D tilt effect
        const advancedSection = document.createElement("div");
        advancedSection.className = "tool-section";
        advancedSection.innerHTML = `
        <h3>Advanced Effects</h3>
        <div class="tool-option">
            <label>3D Tilt:</label>
            <input type="checkbox" id="tiltEffect">
        </div>
        <div class="tool-option">
            <label>Parallax Level:</label>
            <input type="range" id="parallaxLevel" min="1" max="10" value="3">
        </div>
        <div class="tool-option">
            <label>Time of Day:</label>
            <input type="range" id="timeOfDay" min="0" max="24" step="0.5" value="12">
        </div>
        <button id="applyAdvancedEffects">Apply Effects</button>
    `;

        document
          .querySelector(".sidebar")
          .insertBefore(
            advancedSection,
            document.querySelector(".tool-section:last-child")
          );

        // Implement advanced effects
        document
          .getElementById("applyAdvancedEffects")
          .addEventListener("click", () => {
            const tiltEnabled = document.getElementById("tiltEffect").checked;
            const parallaxLevel = parseInt(
              document.getElementById("parallaxLevel").value
            );
            const timeOfDay = parseFloat(
              document.getElementById("timeOfDay").value
            );

            // Apply time of day color effect
            let colorMatrix = new PIXI.filters.ColorMatrixFilter();

            if (timeOfDay < 6) {
              // Night
              colorMatrix.brightness(0.7, false);
              colorMatrix.contrast(1.2, false);
              colorMatrix.hue(240, false); // Blue tint
            } else if (timeOfDay < 8) {
              // Sunrise
              colorMatrix.brightness(0.9, false);
              colorMatrix.saturate(1.5, false);
              colorMatrix.hue(30, false); // Orange tint
            } else if (timeOfDay < 18) {
              // Day
              colorMatrix.brightness(1.1, false);
              colorMatrix.saturate(1.1, false);
            } else if (timeOfDay < 20) {
              // Sunset
              colorMatrix.brightness(0.9, false);
              colorMatrix.saturate(1.5, false);
              colorMatrix.hue(350, false); // Reddish tint
            } else {
              // Night
              colorMatrix.brightness(0.7, false);
              colorMatrix.contrast(1.2, false);
              colorMatrix.hue(240, false); // Blue tint
            }

            // Apply to background
            layers.background.filters = [colorMatrix];

            // Setup 3D tilt if enabled
            if (tiltEnabled) {
              // Create parallax effect on mouse move
              const mouseHandler = (e) => {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;

                const mouseX = e.clientX;
                const mouseY = e.clientY;

                const offsetX = (mouseX - centerX) / centerX;
                const offsetY = (mouseY - centerY) / centerY;

                // Apply different movement based on layer (parallax)
                Object.keys(layers).forEach((layerName, i) => {
                  const layer = layers[layerName];
                  const multiplier =
                    (Object.keys(layers).length - i) * (parallaxLevel / 5);

                  layer.position.x = offsetX * 20 * multiplier;
                  layer.position.y = offsetY * 10 * multiplier;

                  // Add subtle rotation for 3D effect
                  layer.rotation = offsetX * 0.05;

                  // Add subtle scaling
                  const scale =
                    1 + Math.abs(offsetX * 0.05) + Math.abs(offsetY * 0.05);
                  layer.scale.set(scale, scale);
                });
              };

              // Add mouse move handler
              document.removeEventListener("mousemove", mouseHandler);
              document.addEventListener("mousemove", mouseHandler);

              // Add information message
              alert(
                "3D tilt effect enabled! Move your mouse to see the effect."
              );
            }
          });

        // Handle window resize
        window.addEventListener("resize", () => {
          // Update the background
          if (layers.background.children.length > 0) {
            applyGradientBackground();
          }
        });
      });
    </script>
  </body>
</html>
