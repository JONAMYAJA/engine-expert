<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mario-style Platformer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #gameUI { position: fixed; top: 20px; left: 20px; color: white; font-size: 24px; z-index: 100; }
        #lives { display: flex; gap: 10px; margin-bottom: 10px; }
        .life { width: 25px; height: 25px; background: #ff0000; border-radius: 50%; }
        #powerUpTimer { color: #ffff00; margin-bottom: 10px; display: none; }
        #gameOver { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 10px;
            color: white; text-align: center; display: none; z-index: 1000;
        }
        #restartButton {
            margin-top: 20px; padding: 10px 20px; background: #ff5722;
            border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 18px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameUI">
        <div id="lives"></div>
        <div id="powerUpTimer"></div>
        <div id="score">Score: 0</div>
    </div>
    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>
    
    <!-- Audio elements for game sounds -->
    <audio id="coinSound" src="Assets/coin.mp3.mp3" preload="auto"></audio>
    <audio id="powerUpSound" src="Coin.mp3" preload="auto"></audio>
    <audio id="jumpSound" src="Assets/JUMP.mp3.mp3" preload="auto"></audio>
    <audio id="enemyHitSound" src="Assets/Shoot.mp3.mp3" preload="auto"></audio>

    <script>
        // Game starts when page loads
        window.onload = function() {
            const game = new MarioPlatformer();
            game.start();
        };

        class MarioPlatformer {
            constructor() {
                // Setup canvas
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
                
                // Initialize game
                this.init();
            }
            
            init() {
                // Game dimensions
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Game state
                this.lives = 3;
                this.score = 0;
                this.gameOver = false;
                this.hasPowerUp = false;
                this.powerUpTimeLeft = 0;
                this.powerUpDuration = 15 * 60; // 15 seconds at 60fps
                this.lastUpdateTime = 0;
                this.groundY = this.height - 50;
                this.frameCount = 0;
                
                // Animation properties
                this.coinRotation = 0;
                this.platformPulse = 0;
                
                // Transformation animation properties
                this.transforming = false;
                this.transformFrame = 0;
                this.transformMaxFrames = 60;
                this.transformScale = 1;
                this.transformRotation = 0;
                
                // Background properties
                this.skyTime = 0;
                this.mountainsPos = 0;
                this.hillsPos = 0;
                this.treesPos = 0;
                this.clouds = [];
                this.stars = [];
                this.particles = [];
                
                // Generate initial background elements
                this.initBackground();
                
                // Ground scrolling
                this.groundPosition = 0;
                this.groundSpeed = 5;
                
                // Load sounds
                this.sounds = {
                    coin: document.getElementById('coinSound'),
                    powerUp: document.getElementById('powerUpSound'),
                    jump: document.getElementById('jumpSound'),
                    enemyHit: document.getElementById('enemyHitSound')
                };
                
                // Create player with Mario properties
                this.player = {
                    x: 150,
                    y: this.groundY - 50,
                    width: 40,
                    height: 60,
                    velocityX: 0,
                    velocityY: 0,
                    jumping: false,
                    facingRight: true,
                    frame: 0,
                    animSpeed: 5,
                    state: 'idle', // idle, running, jumping, landing
                    animFrame: 0,
                    animTimer: 0,
                    runFrames: 3,
                    jumpFrame: 0,
                    legAngle: 0,
                    armAngle: 0,
                    bobOffset: 0,
                    gunTipX: 0,
                    gunTipY: 0,
                    shooting: false
                };
                
                // Game objects
                this.platforms = [];
                this.coins = [];
                this.enemies = [];
                this.bullets = [];
                this.powerUps = [];
                
                // Physics
                this.gravity = 0.6;
                this.jumpForce = -18;
                this.playerSpeed = 7;
                
                // Controls
                this.keys = {
                    left: false,
                    right: false,
                    up: false,
                    space: false
                };
                
                // Set up initial platforms
                this.generateInitialObjects();
                
                // Set up controls
                this.setupControls();
                
                // Update UI
                this.updateUI();
            }
            
            start() {
                // Start game loop
                requestAnimationFrame(timestamp => this.gameLoop(timestamp));
            }
            
            gameLoop(timestamp) {
                // Calculate delta time
                if (!this.lastUpdateTime) this.lastUpdateTime = timestamp;
                const deltaTime = (timestamp - this.lastUpdateTime) / 1000;
                this.lastUpdateTime = timestamp;
                
                // Update frame counter
                this.frameCount++;
                
                // Clear canvas
                this.ctx.fillStyle = '#8af';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                if (!this.gameOver) {
                    // Update game elements
                    this.updatePlayer(deltaTime);
                    this.updateObjects(deltaTime);
                    this.checkCollisions();
                    this.generateObjects();
                    
                    // Update power-up timer
                    if (this.hasPowerUp) {
                        this.updatePowerUpTimer();
                    }
                }
                
                // Draw game elements
                this.drawBackground();
                this.drawGroundAndObjects();
                this.drawPlayer();
                
                // Request next frame
                requestAnimationFrame(timestamp => this.gameLoop(timestamp));
            }
            
            drawBackground() {
                // Update time for sky cycle (slow movement)
                this.skyTime += 0.0005;
                if (this.skyTime > 1) this.skyTime = 0;
                
                // Create sky gradient based on time
                let gradient = this.ctx.createLinearGradient(0, 0, 0, this.groundY);
                
                // Time-based sky colors (day-sunset-night cycle)
                if (this.skyTime < 0.25) { // Night to dawn
                    const t = this.skyTime * 4;
                    gradient.addColorStop(0, this.lerpColor('#0a0a3a', '#614a92', t));
                    gradient.addColorStop(0.5, this.lerpColor('#0f1a4a', '#cb6284', t));
                    gradient.addColorStop(1, this.lerpColor('#2a2a5a', '#f2a065', t));
                } else if (this.skyTime < 0.5) { // Dawn to day
                    const t = (this.skyTime - 0.25) * 4;
                    gradient.addColorStop(0, this.lerpColor('#614a92', '#1a75cf', t));
                    gradient.addColorStop(0.5, this.lerpColor('#cb6284', '#5d9df0', t));
                    gradient.addColorStop(1, this.lerpColor('#f2a065', '#b0d8f9', t));
                } else if (this.skyTime < 0.75) { // Day to sunset
                    const t = (this.skyTime - 0.5) * 4;
                    gradient.addColorStop(0, this.lerpColor('#1a75cf', '#614a92', t));
                    gradient.addColorStop(0.5, this.lerpColor('#5d9df0', '#da634e', t));
                    gradient.addColorStop(1, this.lerpColor('#b0d8f9', '#f7aa3d', t));
                } else { // Sunset to night
                    const t = (this.skyTime - 0.75) * 4;
                    gradient.addColorStop(0, this.lerpColor('#614a92', '#0a0a3a', t));
                    gradient.addColorStop(0.5, this.lerpColor('#da634e', '#0f1a4a', t));
                    gradient.addColorStop(1, this.lerpColor('#f7aa3d', '#2a2a5a', t));
                }
                
                // Fill sky
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.groundY);
                
                // Draw stars in the night sky
                const starVisibility = Math.max(0, 1 - Math.abs(this.skyTime - 0.9) * 2.5);
                if (starVisibility > 0) {
                    this.stars.forEach(star => {
                        const twinkle = 0.5 + 0.5 * Math.sin(this.frameCount * star.twinkleSpeed + star.twinklePhase);
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${starVisibility * twinkle * 0.8})`;
                        this.ctx.beginPath();
                        this.ctx.arc(star.x, star.y, star.size * twinkle, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                }
                
                // Update and draw parallax backgrounds
                // Distant mountains (slowest)
                this.mountainsPos = (this.mountainsPos - 0.5) % this.width;
                this.drawMountains(this.mountainsPos);
                
                // Draw hills (medium)
                this.hillsPos = (this.hillsPos - 1) % this.width;
                this.drawHills(this.hillsPos);
                
                // Draw trees (faster)
                this.treesPos = (this.treesPos - 1.5) % this.width;
                this.drawTrees(this.treesPos);
                
                // Update and draw clouds
                this.clouds.forEach(cloud => {
                    cloud.x -= cloud.speed;
                    if (cloud.x + cloud.width < 0) {
                        cloud.x = this.width + cloud.width/2;
                        cloud.y = 50 + Math.random() * (this.groundY * 0.4);
                    }
                    
                    this.drawCloud(cloud.x, cloud.y, cloud.width, cloud.height, cloud.opacity);
                });
                
                // Update and draw particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update particle position
                    particle.x += particle.speedX;
                    particle.y += particle.speedY;
                    particle.rotation += particle.rotationSpeed;
                    particle.lifetime--;
                    
                    // Check if particle should be removed
                    if (particle.lifetime <= 0 || 
                        particle.x < -20 || 
                        particle.x > this.width + 20 || 
                        particle.y < -20 || 
                        particle.y > this.groundY + 20) {
                        this.particles.splice(i, 1);
                        this.createParticle(); // Replace with a new one
                        continue;
                    }
                    
                    // Draw particle based on type
                    this.ctx.save();
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    if (particle.type === 0) { // Firefly
                        const blink = 0.5 + 0.5 * Math.sin(this.frameCount * particle.blinkSpeed + particle.blinkPhase);
                        const glowSize = particle.size * (1 + blink * 0.5);
                        
                        // Glow effect
                        const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize * 2);
                        gradient.addColorStop(0, `rgba(255, 255, 180, ${0.7 * blink * particle.opacity})`);
                        gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(-glowSize*2, -glowSize*2, glowSize*4, glowSize*4);
                        
                        // Center dot
                        this.ctx.fillStyle = particle.color;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.size * 0.5 * blink, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                    } else if (particle.type === 1) { // Leaf
                        this.ctx.fillStyle = particle.color;
                        
                        // Draw leaf shape
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -particle.size);
                        this.ctx.bezierCurveTo(
                            particle.size, -particle.size * 0.5,
                            particle.size, particle.size * 0.5,
                            0, particle.size
                        );
                        this.ctx.bezierCurveTo(
                            -particle.size, particle.size * 0.5,
                            -particle.size, -particle.size * 0.5,
                            0, -particle.size
                        );
                        this.ctx.fill();
                        
                        // Leaf vein
                        this.ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 * particle.opacity})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -particle.size);
                        this.ctx.lineTo(0, particle.size);
                        this.ctx.stroke();
                        
                    } else { // Dust
                        this.ctx.fillStyle = particle.color;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                }
                
                // Occasionally add new particles
                if (Math.random() < 0.05) {
                    this.createParticle();
                }
            }
            
            drawGroundAndObjects() {
                // Draw scrolling ground
                this.groundPosition = (this.groundPosition - this.groundSpeed) % 40;
                this.ctx.fillStyle = '#5d3';
                this.ctx.fillRect(0, this.groundY, this.width, this.height - this.groundY);
                
                // Draw ground pattern
                this.ctx.fillStyle = '#496';
                for (let x = this.groundPosition; x < this.width; x += 40) {
                    this.ctx.fillRect(x, this.groundY, 20, 20);
                }
                
                // Update platform animation value
                this.platformPulse = 0.5 + 0.5 * Math.sin(this.frameCount * 0.05);
                
                // Draw platforms with animation
                this.platforms.forEach(platform => {
                    // Platform base with pulse animation
                    this.ctx.fillStyle = '#963';
                    this.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // Platform top with animation
                    this.ctx.fillStyle = platform.highlighted ? '#7d5' : '#6b4';
                    
                    // Pulse effect on top of platform
                    const glowSize = 3 * this.platformPulse;
                    this.ctx.fillRect(platform.x, platform.y, platform.width, 10 + glowSize);
                    
                    // Add a small glow effect if highlighted
                    if (platform.highlighted) {
                        this.ctx.strokeStyle = 'rgba(120, 255, 120, 0.5)';
                        this.ctx.lineWidth = 2 + 2 * this.platformPulse;
                        this.ctx.strokeRect(platform.x - 2, platform.y - 2, platform.width + 4, platform.height + 4);
                    }
                });
                
                // Update coin rotation
                this.coinRotation += 0.1;
                
                // Draw coins with rotation
                this.coins.forEach(coin => {
                    this.ctx.save();
                    this.ctx.translate(coin.x, coin.y);
                    this.ctx.rotate(this.coinRotation);
                    
                    // Outer coin with glow
                    this.ctx.fillStyle = '#fd2';
                    this.ctx.beginPath();
                    this.ctx.ellipse(0, 0, coin.radius, coin.radius * 0.6, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Inner detail
                    this.ctx.fillStyle = '#fc0';
                    this.ctx.beginPath();
                    this.ctx.ellipse(0, 0, coin.radius * 0.7, coin.radius * 0.4, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Dollar sign detail
                    this.ctx.fillStyle = '#fd7';
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('$', 0, 0);
                    
                    this.ctx.restore();
                });
                
                // Draw enemies with animation
                this.enemies.forEach(enemy => {
                    this.ctx.save();
                    
                    // Enemy body with bounce animation
                    const bounceOffset = 3 * Math.sin(this.frameCount * 0.1 + enemy.x * 0.1);
                    
                    // Position at enemy location with bounce
                    this.ctx.translate(enemy.x, enemy.y - enemy.height/2 + bounceOffset);
                    
                    // Add a subtle wobble rotation if moving
                    if (enemy.direction !== 0) {
                        const wobble = 0.1 * Math.sin(this.frameCount * 0.2);
                        this.ctx.rotate(wobble);
                    }
                    
                    // Enemy body
                    this.ctx.fillStyle = '#d23';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, enemy.height/2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Enemy eyes - animated blinking
                    const blinkState = (this.frameCount % 90 > 85) ? 0.2 : 1;
                    
                    // Wiggle eyes based on movement
                    const eyeWobble = enemy.direction * Math.sin(this.frameCount * 0.1) * 2;
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.beginPath();
                    this.ctx.ellipse(-8 + eyeWobble, -5, 5, 5 * blinkState, 0, 0, Math.PI * 2);
                    this.ctx.ellipse(8 + eyeWobble, -5, 5, 5 * blinkState, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Enemy pupils that follow player
                    const playerDirection = Math.atan2(
                        this.player.y - enemy.y,
                        this.player.x - enemy.x
                    );
                    
                    const eyeRadius = 3;
                    const pupilX = Math.cos(playerDirection) * 2;
                    const pupilY = Math.sin(playerDirection) * 2;
                    
                    if (blinkState > 0.5) {
                        this.ctx.fillStyle = 'black';
                        this.ctx.beginPath();
                        this.ctx.arc(-8 + eyeWobble + pupilX, -5 + pupilY, 2, 0, Math.PI * 2);
                        this.ctx.arc(8 + eyeWobble + pupilX, -5 + pupilY, 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Draw angry eyebrows
                    this.ctx.strokeStyle = 'black';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(-12 + eyeWobble, -12);
                    this.ctx.lineTo(-4 + eyeWobble, -8);
                    this.ctx.moveTo(12 + eyeWobble, -12);
                    this.ctx.lineTo(4 + eyeWobble, -8);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                });
                
                // Draw power-ups with enhanced animation effects
                this.powerUps.forEach(powerUp => {
                    // Create a pulsing glow effect around the power-up
                    const glowRadius = powerUp.radius * (1.3 + 0.3 * Math.sin(this.frameCount * 0.1));
                    const gradient = this.ctx.createRadialGradient(
                        powerUp.x, powerUp.y, powerUp.radius * 0.5,
                        powerUp.x, powerUp.y, glowRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 0, 0.7)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    
                    // Draw outer glow
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(powerUp.x, powerUp.y, glowRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw energy rays around the power-up
                    this.ctx.save();
                    this.ctx.translate(powerUp.x, powerUp.y);
                    
                    const rayCount = 8;
                    const rayAngle = (Math.PI * 2) / rayCount;
                    const rayLength = powerUp.radius * (1.2 + 0.4 * Math.sin(this.frameCount * 0.08));
                    
                    this.ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
                    this.ctx.lineWidth = 2;
                    
                    for (let i = 0; i < rayCount; i++) {
                        const angle = i * rayAngle + this.frameCount * 0.02;
                        const x1 = Math.cos(angle) * powerUp.radius;
                        const y1 = Math.sin(angle) * powerUp.radius;
                        const x2 = Math.cos(angle) * rayLength;
                        const y2 = Math.sin(angle) * rayLength;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.stroke();
                    }
                    
                    // Star shape with rotation
                    this.ctx.rotate(this.frameCount * 0.03);
                    
                    // Star shape
                    this.ctx.fillStyle = '#fd2';
                    this.ctx.beginPath();
                    this.drawStar(0, 0, 5, powerUp.radius, powerUp.radius/2);
                    this.ctx.fill();
                    
                    // Inner glow
                    this.ctx.fillStyle = '#ff6';
                    this.ctx.beginPath();
                    this.drawStar(0, 0, 5, powerUp.radius * 0.7, powerUp.radius/3);
                    this.ctx.fill();
                    
                    // Add sparkles around the power-up
                    for (let i = 0; i < 3; i++) {
                        if (Math.random() < 0.3) {
                            const sparkleAngle = Math.random() * Math.PI * 2;
                            const sparkleDistance = powerUp.radius * (1.2 + Math.random() * 0.8);
                            const sparkleX = Math.cos(sparkleAngle) * sparkleDistance;
                            const sparkleY = Math.sin(sparkleAngle) * sparkleDistance;
                            const sparkleSize = 2 + Math.random() * 3;
                            
                            // Draw sparkle
                            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            this.ctx.beginPath();
                            this.ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                });
                
                // Draw bullets with enhanced appearance for mini gun
                this.bullets.forEach(bullet => {
                    // Draw bullet trail with a longer, more dynamic look
                    const trailLength = 25;
                    const trailWidth = bullet.radius * 1.8;
                    
                    // Direction-aware gradient
                    const dirSign = Math.sign(bullet.velocityX);
                    const gradientStartX = bullet.x;
                    const gradientEndX = bullet.x - dirSign * trailLength;
                    
                    const gradient = this.ctx.createLinearGradient(
                        gradientStartX, bullet.y,
                        gradientEndX, bullet.y
                    );
                    
                    gradient.addColorStop(0, 'rgba(255, 120, 0, 0.9)');
                    gradient.addColorStop(0.6, 'rgba(255, 200, 0, 0.5)');
                    gradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    
                    // Draw a tapered trail
                    this.ctx.beginPath();
                    this.ctx.moveTo(bullet.x, bullet.y);
                    this.ctx.lineTo(bullet.x - dirSign * trailLength, bullet.y - trailWidth);
                    this.ctx.lineTo(bullet.x - dirSign * trailLength, bullet.y + trailWidth);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Draw bullet core (metallic look)
                    const bulletGradient = this.ctx.createRadialGradient(
                        bullet.x, bullet.y, 0,
                        bullet.x, bullet.y, bullet.radius
                    );
                    bulletGradient.addColorStop(0, '#fff');
                    bulletGradient.addColorStop(0.3, '#fa3');
                    bulletGradient.addColorStop(1, '#a50');
                    
                    this.ctx.fillStyle = bulletGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add small bright highlight
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x - dirSign * bullet.radius * 0.3, bullet.y - bullet.radius * 0.3, bullet.radius * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add glow effect
                    const bulletGlow = this.ctx.createRadialGradient(
                        bullet.x, bullet.y, 0,
                        bullet.x, bullet.y, bullet.radius * 3
                    );
                    bulletGlow.addColorStop(0, 'rgba(255, 200, 0, 0.5)');
                    bulletGlow.addColorStop(0.5, 'rgba(255, 100, 0, 0.2)');
                    bulletGlow.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    
                    this.ctx.fillStyle = bulletGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(bullet.x, bullet.y, bullet.radius * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawPlayer() {
                // Update animation state based on player movement
                this.updatePlayerAnimation();
                
                // Save the canvas context state
                this.ctx.save();
                
                // Apply transformation effects if transforming
                if (this.transforming) {
                    // Create a scale and rotation effect centered on the player
                    this.ctx.translate(this.player.x, this.player.y - this.player.height/2);
                    this.ctx.scale(this.transformScale, this.transformScale);
                    this.ctx.rotate(this.transformRotation);
                    this.ctx.translate(-this.player.x, -(this.player.y - this.player.height/2));
                    
                    // Add a flashing effect during transformation
                    if (this.transformFrame % 6 < 3) {
                        this.ctx.globalAlpha = 0.8;
                    }
                }
                
                // Translate to player position (center of the character)
                this.ctx.translate(this.player.x, this.player.y - this.player.height/2);
                
                // Flip if facing left
                if (!this.player.facingRight) {
                    this.ctx.scale(-1, 1);
                }
                
                // Apply jump/run bob motion
                this.ctx.translate(0, this.player.bobOffset);
                
                // DRAW MARIO BODY PARTS
                
                // Legs animation
                this.drawMarioLegs();
                
                // Body (overalls)
                this.ctx.fillStyle = '#4466dd'; // Blue overalls
                this.ctx.fillRect(-this.player.width * 0.3, -this.player.height * 0.3, this.player.width * 0.6, this.player.height * 0.5);
                
                // Shirt
                this.ctx.fillStyle = '#dd2222'; // Red shirt
                this.ctx.fillRect(-this.player.width * 0.3, -this.player.height * 0.5, this.player.width * 0.6, this.player.height * 0.25);
                
                // Arms
                this.drawMarioArms();
                
                // Overall straps
                this.ctx.fillStyle = '#4466dd';
                this.ctx.fillRect(-this.player.width * 0.15, -this.player.height * 0.5, this.player.width * 0.1, this.player.height * 0.25);
                this.ctx.fillRect(this.player.width * 0.05, -this.player.height * 0.5, this.player.width * 0.1, this.player.height * 0.25);
                
                // Buttons
                this.ctx.fillStyle = '#ffdd22';
                this.ctx.beginPath();
                this.ctx.arc(-this.player.width * 0.05, -this.player.height * 0.25, this.player.width * 0.05, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.arc(this.player.width * 0.05, -this.player.height * 0.25, this.player.width * 0.05, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Head
                this.ctx.fillStyle = '#ffbb88'; // Skin tone
                this.ctx.beginPath();
                this.ctx.arc(0, -this.player.height * 0.6, this.player.width * 0.25, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Cap
                this.ctx.fillStyle = '#dd2222'; // Red cap
                this.ctx.beginPath();
                this.ctx.ellipse(0, -this.player.height * 0.65, this.player.width * 0.3, this.player.width * 0.2, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Cap details
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.ellipse(0, -this.player.height * 0.72, this.player.width * 0.15, this.player.width * 0.1, 0, 0, Math.PI);
                this.ctx.fill();
                
                // Letter M on cap
                this.ctx.fillStyle = 'white';
                this.ctx.font = `${this.player.width * 0.3}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('M', 0, -this.player.height * 0.68);
                
                // Mustache
                this.ctx.fillStyle = '#653300';
                this.ctx.beginPath();
                this.ctx.ellipse(0, -this.player.height * 0.54, this.player.width * 0.2, this.player.width * 0.08, 0, 0, Math.PI);
                this.ctx.fill();
                
                // Eyes
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(-this.player.width * 0.1, -this.player.height * 0.6, this.player.width * 0.07, 0, Math.PI * 2);
                this.ctx.arc(this.player.width * 0.1, -this.player.height * 0.6, this.player.width * 0.07, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupils
                this.ctx.fillStyle = 'black';
                const lookDirection = this.player.velocityX !== 0 ? Math.sign(this.player.velocityX) : 0;
                this.ctx.beginPath();
                this.ctx.arc(-this.player.width * 0.1 + (lookDirection * 0.02 * this.player.width), -this.player.height * 0.6, this.player.width * 0.03, 0, Math.PI * 2);
                this.ctx.arc(this.player.width * 0.1 + (lookDirection * 0.02 * this.player.width), -this.player.height * 0.6, this.player.width * 0.03, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Nose
                this.ctx.fillStyle = '#ffbb88';
                this.ctx.beginPath();
                this.ctx.arc(this.player.width * 0.15, -this.player.height * 0.55, this.player.width * 0.08, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Enhanced power-up effect on player
                if (this.hasPowerUp) {
                    // Golden aura
                    this.ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 + 0.5 * Math.sin(this.frameCount * 0.1)})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.arc(0, -this.player.height * 0.4, this.player.width * 0.8, 0, Math.PI * 2);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    // Add power-up particles around the player
                    for (let i = 0; i < 2; i++) {
                        if (Math.random() < 0.3) {
                            const particleAngle = Math.random() * Math.PI * 2;
                            const distance = this.player.width * 0.9;
                            const particleX = Math.cos(particleAngle) * distance;
                            const particleY = Math.sin(particleAngle) * distance - this.player.height * 0.4;
                            
                            // Draw star-shaped particle
                            this.ctx.save();
                            this.ctx.translate(particleX, particleY);
                            this.ctx.rotate(this.frameCount * 0.1);
                            
                            this.ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
                            this.ctx.beginPath();
                            this.drawStar(0, 0, 5, 4, 2);
                            this.ctx.fill();
                            
                            this.ctx.restore();
                        }
                    }
                }
                
                // Restore canvas context
                this.ctx.restore();
                
                // Draw transformation effects 
                if (this.transforming && this.transformParticles) {
                    this.ctx.save();
                    this.ctx.translate(this.player.x, this.player.y - this.player.height/2);
                    
                    // Draw all transformation particles
                    for (const particle of this.transformParticles) {
                        // Draw ring particles
                        if (particle.ring) {
                            if (this.transformFrame > particle.delay) {
                                // Fade out as the ring expands
                                const alpha = 1 - (particle.radius / particle.maxRadius);
                                this.ctx.strokeStyle = `${particle.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
                                this.ctx.lineWidth = particle.thickness * alpha;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, particle.radius, 0, Math.PI * 2);
                                this.ctx.stroke();
                            }
                        }
                        // Draw lightning particles
                        else if (particle.lightning) {
                            // Only draw if the lightning is active
                            if (particle.currentFrame < particle.duration) {
                                this.ctx.save();
                                this.ctx.rotate(particle.angle);
                                
                                // Create a zigzag path for lightning
                                this.ctx.beginPath();
                                this.ctx.moveTo(0, 0);
                                
                                const segmentLength = particle.length / particle.segments;
                                let currentX = 0;
                                
                                for (let i = 0; i < particle.segments; i++) {
                                    const nextX = currentX + segmentLength;
                                    const offset = (Math.random() - 0.5) * 15 * (i / particle.segments);
                                    this.ctx.lineTo(nextX, offset);
                                    currentX = nextX;
                                }
                                
                                // Fade based on lifetime
                                const alpha = 1 - (particle.currentFrame / particle.duration);
                                
                                // Draw the lightning with glow
                                this.ctx.strokeStyle = `${particle.color}`;
                                this.ctx.globalAlpha = alpha;
                                this.ctx.lineWidth = particle.width;
                                this.ctx.lineCap = 'round';
                                this.ctx.stroke();
                                
                                // Add glow effect
                                this.ctx.shadowColor = particle.color;
                                this.ctx.shadowBlur = 10;
                                this.ctx.stroke();
                                
                                this.ctx.restore();
                            }
                        }
                        // Draw regular particles
                        else {
                            this.ctx.save();
                            this.ctx.translate(particle.x, particle.y);
                            this.ctx.rotate(particle.rotation);
                            
                            // Fade based on distance
                            const fadeFactor = 1 - (particle.currentDist / particle.maxDist);
                            this.ctx.globalAlpha = fadeFactor;
                            
                            // Different particle types
                            if (particle.type === 0) { // Circle
                                this.ctx.fillStyle = particle.color;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, particle.size, 0, Math.PI * 2);
                                this.ctx.fill();
                            } else if (particle.type === 1) { // Star
                                this.ctx.fillStyle = particle.color;
                                this.ctx.beginPath();
                                this.drawStar(0, 0, 5, particle.size, particle.size/2);
                                this.ctx.fill();
                            } else { // Spark
                                this.ctx.fillStyle = particle.color;
                                // Draw a diamond shape
                                this.ctx.beginPath();
                                this.ctx.moveTo(0, -particle.size);
                                this.ctx.lineTo(particle.size/2, 0);
                                this.ctx.lineTo(0, particle.size);
                                this.ctx.lineTo(-particle.size/2, 0);
                                this.ctx.closePath();
                                this.ctx.fill();
                            }
                            
                            this.ctx.restore();
                        }
                    }
                    
                    this.ctx.restore();
                }
            }
            
            updatePlayer(deltaTime) {
                // Initialize gun properties if not exist
                if (this.hasPowerUp && !this.player.gunTipX) {
                    this.player.gunTipX = 40;
                    this.player.gunTipY = 0;
                    this.player.shooting = false;
                }
                
                // Horizontal movement with improved responsiveness
                if (this.keys.left) {
                    // Gradually accelerate when changing direction
                    if (this.player.velocityX > 0) {
                        this.player.velocityX = Math.max(this.player.velocityX - 1.5, -this.playerSpeed);
                    } else {
                        this.player.velocityX = Math.max(this.player.velocityX - 0.8, -this.playerSpeed);
                    }
                    this.player.facingRight = false;
                } else if (this.keys.right) {
                    // Gradually accelerate when changing direction
                    if (this.player.velocityX < 0) {
                        this.player.velocityX = Math.min(this.player.velocityX + 1.5, this.playerSpeed);
                    } else {
                        this.player.velocityX = Math.min(this.player.velocityX + 0.8, this.playerSpeed);
                    }
                    this.player.facingRight = true;
                } else {
                    // Decelerate when no movement keys are pressed
                    if (this.player.velocityX > 0.5) {
                        this.player.velocityX -= 0.5;
                    } else if (this.player.velocityX < -0.5) {
                        this.player.velocityX += 0.5;
                    } else {
                        this.player.velocityX = 0;
                    }
                }
                
                // Apply gravity
                this.player.velocityY += this.gravity;
                
                // Update position
                this.player.x += this.player.velocityX;
                this.player.y += this.player.velocityY;
                
                // Ground collision
                if (this.player.y > this.groundY) {
                    this.player.y = this.groundY;
                    this.player.velocityY = 0;
                    this.player.jumping = false;
                }
                
                // Screen bounds
                if (this.player.x < this.player.width/2) {
                    this.player.x = this.player.width/2;
                }
                if (this.player.x > this.width * 0.6) {
                    this.player.x = this.width * 0.6;
                }
                
                // Auto-shoot if has power-up - REDUCED FIRE RATE from 10 to 25 frames
                if (this.hasPowerUp && this.frameCount % 25 === 0) {
                    this.shoot();
                }
            }
            
            updateObjects(deltaTime) {
                // Update platforms
                for (let i = this.platforms.length - 1; i >= 0; i--) {
                    const platform = this.platforms[i];
                    platform.x -= this.groundSpeed;
                    
                    // Highlight platforms near the player (for visual cue)
                    const playerDistance = Math.abs(this.player.x - platform.x - platform.width/2);
                    platform.highlighted = playerDistance < 200;
                    
                    if (platform.x + platform.width < 0) {
                        this.platforms.splice(i, 1);
                    }
                }
                
                // Update coins
                for (let i = this.coins.length - 1; i >= 0; i--) {
                    const coin = this.coins[i];
                    coin.x -= this.groundSpeed;
                    
                    // Coin floating animation
                    coin.y += Math.sin(this.frameCount * 0.1) * 0.5;
                    
                    if (coin.x + coin.radius < 0) {
                        this.coins.splice(i, 1);
                    }
                }
                
                // Update enemies with improved movement
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    // Basic movement (scroll with screen)
                    enemy.x -= this.groundSpeed;
                    
                    // Add some random movement for enemies on ground
                    if (!enemy.onPlatform && Math.random() < 0.02) {
                        enemy.direction = Math.random() < 0.5 ? -1 : 1;
                    }
                    
                    // Apply enemy's own movement
                    enemy.x += enemy.direction * enemy.speed * 0.5;
                    
                    if (enemy.x + enemy.width < 0) {
                        this.enemies.splice(i, 1);
                    }
                }
                
                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.x += bullet.velocityX;
                    
                    if (bullet.x - bullet.radius > this.width) {
                        this.bullets.splice(i, 1);
                    }
                }
                
                // Update power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.x -= this.groundSpeed;
                    
                    // Power-up floating animation
                    powerUp.y += Math.sin(this.frameCount * 0.1) * 0.7;
                    
                    if (powerUp.x + powerUp.radius < 0) {
                        this.powerUps.splice(i, 1);
                    }
                }
            }
            
            checkCollisions() {
                // Platform collisions - improved to handle landing better
                let onPlatform = false;
                for (const platform of this.platforms) {
                    if (this.player.velocityY > 0 && // Only check when falling
                        this.player.x + this.player.width/2 > platform.x &&
                        this.player.x - this.player.width/2 < platform.x + platform.width &&
                        this.player.y > platform.y - 15 && // More forgiving collision detection
                        this.player.y < platform.y + platform.height/2) {
                        
                        this.player.y = platform.y;
                        this.player.velocityY = 0;
                        this.player.jumping = false;
                        onPlatform = true;
                    }
                }
                
                // Update enemies to follow platforms
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    // Check if enemy is on a platform or ground
                    let onSurface = false;
                    if (enemy.y >= this.groundY) {
                        enemy.y = this.groundY;
                        onSurface = true;
                    } else {
                        // Check if on platform
                        for (const platform of this.platforms) {
                            if (enemy.x + enemy.width/2 > platform.x &&
                                enemy.x - enemy.width/2 < platform.x + platform.width &&
                                Math.abs(enemy.y - platform.y) < 5) {
                                
                                enemy.y = platform.y;
                                onSurface = true;
                                
                                // Don't walk off platforms
                                if (enemy.x - enemy.width/2 < platform.x) {
                                    enemy.x = platform.x + enemy.width/2;
                                    enemy.direction = 1; // Move right
                                } else if (enemy.x + enemy.width/2 > platform.x + platform.width) {
                                    enemy.x = platform.x + platform.width - enemy.width/2;
                                    enemy.direction = -1; // Move left
                                }
                                break;
                            }
                        }
                    }
                    
                    if (!onSurface) {
                        // Apply gravity to enemies in air
                        enemy.y += this.gravity * 2;
                    }
                }
                
                // Coin collisions
                for (let i = this.coins.length - 1; i >= 0; i--) {
                    const coin = this.coins[i];
                    
                    if (this.circleRectCollision(
                        coin.x, coin.y, coin.radius,
                        this.player.x - this.player.width/2, 
                        this.player.y - this.player.height, 
                        this.player.width, 
                        this.player.height
                    )) {
                        this.coins.splice(i, 1);
                        this.score += 10;
                        this.updateUI();
                        
                        // Play coin sound
                        this.playSound('coin');
                    }
                }
                
                // Enemy collisions
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    if (this.circleRectCollision(
                        enemy.x, enemy.y - enemy.height/2, enemy.width/2,
                        this.player.x - this.player.width/2, 
                        this.player.y - this.player.height, 
                        this.player.width, 
                        this.player.height
                    )) {
                        this.enemies.splice(i, 1);
                        this.loseLife();
                    }
                }
                
                // Power-up collisions
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    
                    if (this.circleRectCollision(
                        powerUp.x, powerUp.y, powerUp.radius,
                        this.player.x - this.player.width/2, 
                        this.player.y - this.player.height, 
                        this.player.width, 
                        this.player.height
                    )) {
                        this.powerUps.splice(i, 1);
                        this.activatePowerUp();
                        
                        // Play power-up sound
                        this.playSound('powerUp');
                    }
                }
                
                // Bullet-enemy collisions
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        
                        if (this.circleCircleCollision(
                            bullet.x, bullet.y, bullet.radius,
                            enemy.x, enemy.y - enemy.height/2, enemy.width/2
                        )) {
                            this.bullets.splice(i, 1);
                            this.enemies.splice(j, 1);
                            this.score += 20;
                            this.updateUI();
                            
                            // Play enemy hit sound
                            this.playSound('enemyHit');
                            break;
                        }
                    }
                }
            }
            
            generateInitialObjects() {
                // Initial platforms with proper spacing
                const platformPositions = [300, 900]; // Increased spacing to 600px between platforms
                
                for (let i = 0; i < 2; i++) {
                    this.platforms.push({
                        x: platformPositions[i],
                        y: this.groundY - 80 - Math.random() * 100,
                        width: 150,
                        height: 30,
                        highlighted: false  // Add highlighted property for animation
                    });
                }
                
                // Initial coins with proper spacing
                const coinPositions = [400, 1000]; // Increased spacing to 600px between coins
                
                for (let i = 0; i < 2; i++) {
                    this.coins.push({
                        x: coinPositions[i],
                        y: this.groundY - 150 - Math.random() * 100,
                        radius: 15
                    });
                }
                
                // Initial power-up (moved further away)
                this.powerUps.push({
                    x: 1500, // Moved even further away
                    y: this.groundY - 200,
                    radius: 20
                });
                
                // Initial enemy - just one to start
                this.enemies.push({
                    x: 1200,
                    y: this.groundY,
                    width: 50,
                    height: 50,
                    speed: 1 + Math.random() * 2,
                    direction: Math.random() < 0.5 ? -1 : 1,
                    onPlatform: false
                });
            }
            
            generateObjects() {
                // Generate platforms (with overlap prevention)
                if (Math.random() < 0.01 && this.platforms.length < 5) {
                    const spawnX = this.width + 50;
                    let canSpawnPlatform = true;
                    
                    // Check for overlaps with existing platforms
                    for (const platform of this.platforms) {
                        const distance = Math.abs(platform.x - spawnX);
                        // Ensure at least 350px between platforms
                        if (distance < 350) {
                            canSpawnPlatform = false;
                            break;
                        }
                    }
                    
                    if (canSpawnPlatform) {
                        this.platforms.push({
                            x: spawnX,
                            y: this.groundY - 80 - Math.random() * 100,
                            width: 100 + Math.random() * 150,
                            height: 30,
                            highlighted: false  // Add highlighted property for animation
                        });
                    }
                }
                
                // Generate coins
                if (Math.random() < 0.005) {
                    // Single coins or very small groups
                    const baseY = this.groundY - 150 - Math.random() * 100;
                    const coinCount = Math.floor(1 + Math.random() * 2);
                    
                    for (let i = 0; i < coinCount; i++) {
                        this.coins.push({
                            x: this.width + 50 + i * 80,
                            y: baseY + Math.sin(i * 0.5) * 30,
                            radius: 15
                        });
                    }
                }
                
                // Generate enemies (significantly reduced from 0.008 to 0.003)
                if (Math.random() < 0.003 && this.enemies.length < 3) {
                    // Check if there's already an enemy near the spawn point
                    const spawnX = this.width + 50;
                    let canSpawn = true;
                    
                    // Make sure we're not spawning too close to other enemies
                    for (const enemy of this.enemies) {
                        const distance = Math.abs(enemy.x - spawnX);
                        if (distance < 300) {
                            canSpawn = false;
                            break;
                        }
                    }
                    
                    if (canSpawn) {
                        // Decide if enemy should be on a platform or ground
                        let enemyY = this.groundY;
                        let onPlatform = false;
                        
                        // Sometimes place enemies on platforms
                        if (Math.random() < 0.3 && this.platforms.length > 0) {
                            // Find a suitable platform
                            const platformsInView = this.platforms.filter(p => 
                                p.x > this.width/2 && p.x < this.width * 1.5);
                            
                            if (platformsInView.length > 0) {
                                const platform = platformsInView[Math.floor(Math.random() * platformsInView.length)];
                                enemyY = platform.y;
                                onPlatform = true;
                            }
                        }
                        
                        this.enemies.push({
                            x: spawnX,
                            y: enemyY,
                            width: 50,
                            height: 50,
                            speed: 1 + Math.random() * 2,
                            direction: Math.random() < 0.5 ? -1 : 1,
                            onPlatform: onPlatform
                        });
                    }
                }
                
                // Generate power-ups (less frequent)
                if (Math.random() < 0.002) {
                    // Make sure power-ups don't overlap with existing objects
                    const spawnX = this.width + 50;
                    let validPosition = true;
                    
                    for (const powerUp of this.powerUps) {
                        if (Math.abs(powerUp.x - spawnX) < 400) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    if (validPosition) {
                        this.powerUps.push({
                            x: spawnX,
                            y: this.groundY - 180 - Math.random() * 50,
                            radius: 20
                        });
                    }
                }
            }
            
            setupControls() {
                window.addEventListener('keydown', (e) => {
                    if (this.gameOver) return;
                    
                    switch (e.key) {
                        case 'ArrowLeft':
                            this.keys.left = true;
                            break;
                        case 'ArrowRight':
                            this.keys.right = true;
                            break;
                        case 'ArrowUp':
                        case ' ':
                            if (!this.player.jumping) {
                                this.player.jumping = true;
                                this.player.velocityY = this.jumpForce;
                                // Play jump sound
                                this.playSound('jump');
                            }
                            break;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    switch (e.key) {
                        case 'ArrowLeft':
                            this.keys.left = false;
                            break;
                        case 'ArrowRight':
                            this.keys.right = false;
                            break;
                    }
                });
                
                // Mobile touch controls
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const x = touch.clientX;
                    
                    if (x < this.width/3) {
                        this.keys.left = true;
                        this.keys.right = false;
                    } else if (x > this.width * 2/3) {
                        this.keys.right = true;
                        this.keys.left = false;
                    } else if (!this.player.jumping) {
                        this.player.jumping = true;
                        this.player.velocityY = this.jumpForce;
                        // Play jump sound
                        this.playSound('jump');
                    }
                });
                
                this.canvas.addEventListener('touchend', () => {
                    this.keys.left = false;
                    this.keys.right = false;
                });
                
                document.getElementById('restartButton').addEventListener('click', () => {
                    this.restart();
                });
            }
            
            // Play a sound from the sound library
            playSound(soundName) {
                try {
                    // Use the proper sound element based on sound type
                    let sound;
                    if (soundName === 'coin') {
                        sound = document.getElementById('coinSound');
                    } else if (soundName === 'jump') {
                        sound = document.getElementById('jumpSound');
                    } else if (soundName === 'powerUp') {
                        sound = document.getElementById('powerUpSound');
                    } else if (soundName === 'enemyHit') {
                        sound = document.getElementById('enemyHitSound');
                    }
                    
                    if (sound) {
                        // Reset sound to beginning
                        sound.currentTime = 0;
                        // Set volume to maximum
                        sound.volume = 1.0;
                        // Force play with user interaction
                        const playPromise = sound.play();
                        
                        if (playPromise !== undefined) {
                            playPromise.catch(error => {
                                console.log("Sound play error:", error);
                            });
                        }
                    }
                } catch (e) {
                    console.log('Sound error:', e);
                }
            }
            
            shoot() {
                // Calculate gun tip position in world coordinates
                let gunTipX, gunTipY;
                
                if (this.player.facingRight) {
                    // When facing right, use the stored coordinates 
                    gunTipX = this.player.x + this.player.gunTipX;
                    gunTipY = this.player.y - this.player.height/2 + this.player.gunTipY + this.player.bobOffset;
                } else {
                    // When facing left, mirror the gun position
                    gunTipX = this.player.x - this.player.gunTipX;
                    gunTipY = this.player.y - this.player.height/2 + this.player.gunTipY + this.player.bobOffset;
                }
                
                // Set player shooting flag for muzzle flash animation
                this.player.shooting = true;
                setTimeout(() => { this.player.shooting = false; }, 100);
                
                // Create bullet at gun tip
                this.bullets.push({
                    x: gunTipX,
                    y: gunTipY,
                    radius: 5,
                    velocityX: this.player.facingRight ? 20 : -20
                });
                
                // Play sound effect
                this.playSound('enemyHit');
            }
            
            activatePowerUp() {
                this.hasPowerUp = true;
                this.powerUpTimeLeft = this.powerUpDuration;
                document.getElementById('powerUpTimer').style.display = 'block';
            }
            
            updatePowerUpTimer() {
                this.powerUpTimeLeft--;
                const secondsLeft = Math.ceil(this.powerUpTimeLeft / 60);
                document.getElementById('powerUpTimer').textContent = `Mini-Gun Power: ${secondsLeft}s`;
                
                if (this.powerUpTimeLeft <= 0) {
                    this.hasPowerUp = false;
                    document.getElementById('powerUpTimer').style.display = 'none';
                }
            }
            
            loseLife() {
                this.lives--;
                this.updateUI();
                
                if (this.lives <= 0) {
                    this.endGame();
                }
            }
            
            endGame() {
                this.gameOver = true;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restart() {
                this.init();
                document.getElementById('gameOver').style.display = 'none';
            }
            
            updateUI() {
                document.getElementById('score').textContent = `Score: ${this.score}`;
                
                const livesContainer = document.getElementById('lives');
                livesContainer.innerHTML = '';
                
                for (let i = 0; i < this.lives; i++) {
                    const life = document.createElement('div');
                    life.className = 'life';
                    livesContainer.appendChild(life);
                }
            }
            
            // Collision detection utilities
            circleRectCollision(circleX, circleY, radius, rectX, rectY, rectWidth, rectHeight) {
                const closestX = Math.max(rectX, Math.min(circleX, rectX + rectWidth));
                const closestY = Math.max(rectY, Math.min(circleY, rectY + rectHeight));
                
                const distanceX = circleX - closestX;
                const distanceY = circleY - closestY;
                
                return (distanceX * distanceX + distanceY * distanceY) < (radius * radius);
            }
            
            circleCircleCollision(x1, y1, r1, x2, y2, r2) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                return distance < r1 + r2;
            }
            
            drawStar(cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                let step = Math.PI / spikes;
                
                this.ctx.beginPath();
                this.ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    this.ctx.lineTo(x, y);
                    rot += step;
                    
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    this.ctx.lineTo(x, y);
                    rot += step;
                }
                
                this.ctx.lineTo(cx, cy - outerRadius);
                this.ctx.closePath();
            }
            
            // Add methods for drawing parallax background elements
            drawMountains(offset) {
                // Distant mountains silhouette
                this.ctx.fillStyle = 'rgba(40, 40, 80, 0.7)';
                
                // Create a path for mountains
                this.ctx.beginPath();
                this.ctx.moveTo(offset, this.groundY);
                
                // First mountain range
                for (let x = 0; x <= this.width + 200; x += 50) {
                    const height = 150 + Math.sin(x * 0.01) * 50 + Math.sin(x * 0.02) * 30;
                    this.ctx.lineTo(offset + x, this.groundY - height);
                }
                
                // Complete the shape
                this.ctx.lineTo(offset + this.width + 200, this.groundY);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Second mountain range (darker)
                this.ctx.fillStyle = 'rgba(30, 30, 60, 0.8)';
                this.ctx.beginPath();
                this.ctx.moveTo(offset - 100, this.groundY);
                
                for (let x = 0; x <= this.width + 400; x += 70) {
                    const height = 200 + Math.sin(x * 0.008 + 2) * 80 + Math.sin(x * 0.015 + 1) * 40;
                    this.ctx.lineTo(offset - 100 + x, this.groundY - height);
                }
                
                this.ctx.lineTo(offset + this.width + 300, this.groundY);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Add snow caps on mountains if in daytime
                if (this.skyTime > 0.3 && this.skyTime < 0.7) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    this.ctx.beginPath();
                    
                    for (let x = 0; x <= this.width + 400; x += 70) {
                        const mountainHeight = 200 + Math.sin(x * 0.008 + 2) * 80 + Math.sin(x * 0.015 + 1) * 40;
                        const snowHeight = mountainHeight * 0.2;
                        const baseY = this.groundY - mountainHeight;
                        
                        // Draw triangle snow caps
                        this.ctx.moveTo(offset - 100 + x - 20, baseY + snowHeight * 1.5);
                        this.ctx.lineTo(offset - 100 + x, baseY);
                        this.ctx.lineTo(offset - 100 + x + 20, baseY + snowHeight * 1.5);
                    }
                    
                    this.ctx.fill();
                }
            }
            
            drawHills(offset) {
                // Mid-distance hills
                const hillGreen = this.lerpColor('#1a472a', '#2d8659', Math.min(1, Math.max(0, (this.skyTime - 0.2) * 2)));
                this.ctx.fillStyle = hillGreen;
                
                // Create smooth hills
                this.ctx.beginPath();
                this.ctx.moveTo(offset, this.groundY);
                
                // Use cosine waves for smooth hills
                for (let x = 0; x <= this.width + 200; x += 10) {
                    const height = 80 + 40 * Math.cos(x * 0.01) + 30 * Math.cos(x * 0.03);
                    this.ctx.lineTo(offset + x, this.groundY - height);
                }
                
                this.ctx.lineTo(offset + this.width + 200, this.groundY);
                this.ctx.closePath();
                this.ctx.fill();
                
                // Second layer of closer hills
                const hillColor2 = this.lerpColor('#2d533d', '#3d9668', Math.min(1, Math.max(0, (this.skyTime - 0.2) * 2)));
                this.ctx.fillStyle = hillColor2;
                this.ctx.beginPath();
                this.ctx.moveTo(offset - 100, this.groundY);
                
                for (let x = 0; x <= this.width + 400; x += 15) {
                    const height = 60 + 25 * Math.cos(x * 0.02 + 1) + 15 * Math.cos(x * 0.05);
                    this.ctx.lineTo(offset - 100 + x, this.groundY - height);
                }
                
                this.ctx.lineTo(offset + this.width + 300, this.groundY);
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawTrees(offset) {
                // Draw distant tree silhouettes
                for (let i = 0; i < 20; i++) {
                    const x = (offset + i * 150) % (this.width + 300) - 100;
                    const y = this.groundY - 20 - (i % 3) * 15;
                    const height = 70 + (i % 4) * 20;
                    const width = 40 + (i % 3) * 10;
                    
                    // Tree types alternate
                    if (i % 3 === 0) {
                        this.drawPineTree(x, y, width, height);
                    } else {
                        this.drawBroadTree(x, y, width, height);
                    }
                }
            }
            
            drawPineTree(x, y, width, height) {
                // Tree trunk
                this.ctx.fillStyle = '#5e3a1a';
                this.ctx.fillRect(x - width * 0.15, y - height * 0.3, width * 0.3, height * 0.3);
                
                // Tree foliage
                this.ctx.fillStyle = '#1a4729';
                
                // Multiple triangle layers
                for (let i = 0; i < 3; i++) {
                    const layerY = y - height * (0.3 + i * 0.25);
                    const layerWidth = width * (1 - i * 0.2);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, layerY - height * 0.25);
                    this.ctx.lineTo(x - layerWidth / 2, layerY);
                    this.ctx.lineTo(x + layerWidth / 2, layerY);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            drawBroadTree(x, y, width, height) {
                // Tree trunk
                this.ctx.fillStyle = '#6e4a2a';
                this.ctx.fillRect(x - width * 0.1, y - height * 0.4, width * 0.2, height * 0.4);
                
                // Tree canopy
                this.ctx.fillStyle = '#276339';
                this.ctx.beginPath();
                this.ctx.arc(x, y - height * 0.4, width * 0.5, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Updated method for drawing clouds
            drawCloud(x, y, width, height, opacity) {
                this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                
                // Draw a more detailed cloud shape
                this.ctx.beginPath();
                
                // Main cloud body
                this.ctx.arc(x, y, height/2, 0, Math.PI * 2);
                this.ctx.arc(x + width * 0.2, y - height * 0.1, height * 0.6, 0, Math.PI * 2);
                this.ctx.arc(x + width * 0.4, y + height * 0.1, height * 0.7, 0, Math.PI * 2);
                this.ctx.arc(x + width * 0.7, y - height * 0.05, height * 0.6, 0, Math.PI * 2);
                this.ctx.arc(x + width * 0.9, y + height * 0.1, height * 0.5, 0, Math.PI * 2);
                
                this.ctx.fill();
                
                // Add subtle shadow at the bottom
                const gradient = this.ctx.createLinearGradient(x, y, x, y + height/2);
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.ellipse(x + width/2, y + height/4, width/2, height/3, 0, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Add the missing initBackground method
            initBackground() {
                // Generate initial clouds with varied sizes
                for (let i = 0; i < 15; i++) {
                    this.clouds.push({
                        x: Math.random() * this.width * 2,
                        y: 50 + Math.random() * (this.groundY * 0.4),
                        width: 100 + Math.random() * 150,
                        height: 40 + Math.random() * 40,
                        speed: 0.2 + Math.random() * 0.3,
                        opacity: 0.5 + Math.random() * 0.4
                    });
                }
                
                // Generate stars for night sky
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.width,
                        y: Math.random() * (this.groundY * 0.8),
                        size: 1 + Math.random() * 2,
                        twinkleSpeed: 0.03 + Math.random() * 0.05,
                        twinklePhase: Math.random() * Math.PI * 2
                    });
                }
                
                // Generate initial particles
                for (let i = 0; i < 50; i++) {
                    this.createParticle();
                }
            }
            
            // Add the missing createParticle method
            createParticle() {
                // Different types of particles: 0=firefly, 1=leaf, 2=dust, 3=power-up
                const type = Math.floor(Math.random() * 3);
                
                let particle = {
                    x: Math.random() * this.width,
                    y: Math.random() * this.groundY * 0.8,
                    size: 2 + Math.random() * 4,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 0.5,
                    type: type,
                    opacity: 0.6 + Math.random() * 0.4,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    lifetime: 100 + Math.random() * 200
                };
                
                // Type-specific properties
                if (type === 0) { // Firefly
                    particle.color = `hsl(60, 100%, ${70 + Math.random() * 30}%)`;
                    particle.blinkSpeed = 0.05 + Math.random() * 0.05;
                    particle.blinkPhase = Math.random() * Math.PI * 2;
                } else if (type === 1) { // Leaf
                    particle.color = `hsl(${80 + Math.random() * 40}, 80%, 40%)`;
                    particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                    particle.speedY = 0.3 + Math.random() * 0.5; // Leaves fall down
                } else if (type === 2) { // Dust
                    particle.color = `hsla(40, 70%, 80%, ${0.3 + Math.random() * 0.3})`;
                    particle.speedY = -0.1 - Math.random() * 0.3; // Dust rises
                } else if (type === 3) { // Power-up particle
                    particle.color = `hsl(${40 + Math.random() * 20}, 100%, 60%)`;
                    particle.blinkSpeed = 0.1 + Math.random() * 0.1;
                    particle.blinkPhase = Math.random() * Math.PI * 2;
                    // These are created manually, not through this method
                }
                
                this.particles.push(particle);
            }
            
            // Add the missing lerpColor helper method
            lerpColor(color1, color2, t) {
                // Convert hex to RGB
                const parseColor = (hex) => {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return [r, g, b];
                };
                
                const [r1, g1, b1] = parseColor(color1);
                const [r2, g2, b2] = parseColor(color2);
                
                // Interpolate
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                // Convert back to hex
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            // Add new method to animate Mario's legs
            drawMarioLegs() {
                const legWidth = this.player.width * 0.15;
                const legLength = this.player.height * 0.25;
                
                // Calculate leg positions based on animation state
                let leftLegAngle = 0;
                let rightLegAngle = 0;
                
                if (this.player.state === 'running') {
                    // Running animation - alternating leg movement
                    const cycle = Math.sin(this.player.animTimer * 0.4);
                    leftLegAngle = cycle * 0.5;
                    rightLegAngle = -cycle * 0.5;
                } else if (this.player.state === 'jumping') {
                    // Jumping animation - legs spread
                    leftLegAngle = -0.3;
                    rightLegAngle = 0.3;
                }
                
                // Draw left leg
                this.ctx.save();
                this.ctx.fillStyle = '#4466dd'; // Blue overalls
                this.ctx.translate(-legWidth, this.player.height * 0.2);
                this.ctx.rotate(leftLegAngle);
                this.ctx.fillRect(-legWidth/2, 0, legWidth, legLength);
                
                // Left boot
                this.ctx.fillStyle = '#653300'; // Brown boot
                this.ctx.fillRect(-legWidth/2 - 5, legLength - 5, legWidth + 10, 15);
                this.ctx.restore();
                
                // Draw right leg
                this.ctx.save();
                this.ctx.fillStyle = '#4466dd'; // Blue overalls
                this.ctx.translate(legWidth, this.player.height * 0.2);
                this.ctx.rotate(rightLegAngle);
                this.ctx.fillRect(-legWidth/2, 0, legWidth, legLength);
                
                // Right boot
                this.ctx.fillStyle = '#653300'; // Brown boot
                this.ctx.fillRect(-legWidth/2 - 5, legLength - 5, legWidth + 10, 15);
                this.ctx.restore();
            }
            
            // Add new method to animate Mario's arms
            drawMarioArms() {
                const armWidth = this.player.width * 0.15;
                const armLength = this.player.height * 0.25;
                
                // Calculate arm positions based on animation state
                let leftArmAngle = 0;
                let rightArmAngle = 0;
                
                if (this.player.state === 'running') {
                    // Running animation - alternating arm movement
                    const cycle = Math.sin(this.player.animTimer * 0.4);
                    leftArmAngle = -cycle * 0.5;
                    rightArmAngle = cycle * 0.5;
                } else if (this.player.state === 'jumping') {
                    // Jumping animation - arms up
                    leftArmAngle = -0.8;
                    rightArmAngle = -0.8;
                } else if (this.hasPowerUp) {
                    // When powered up, extend right arm forward for gun
                    rightArmAngle = 0.1;
                }
                
                // Arm position offsets
                const shoulderOffsetY = -this.player.height * 0.45;
                
                // Draw left arm
                this.ctx.save();
                this.ctx.fillStyle = '#dd2222'; // Red shirt
                this.ctx.translate(-this.player.width * 0.3, shoulderOffsetY);
                this.ctx.rotate(leftArmAngle);
                this.ctx.fillRect(-armWidth/2, 0, armWidth, armLength);
                
                // Left glove
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(0, armLength + 5, armWidth * 0.8, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // Draw right arm
                this.ctx.save();
                this.ctx.fillStyle = '#dd2222'; // Red shirt
                this.ctx.translate(this.player.width * 0.3, shoulderOffsetY);
                this.ctx.rotate(rightArmAngle);
                this.ctx.fillRect(-armWidth/2, 0, armWidth, armLength);
                
                // Right glove
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(0, armLength + 5, armWidth * 0.8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw mini gun if powered up
                if (this.hasPowerUp) {
                    // Get hand position for gun placement
                    const handX = 0;
                    const handY = armLength + 5;
                    
                    // Store gun position for bullet spawning (in player coordinates)
                    this.player.gunTipX = handX + 40;
                    this.player.gunTipY = handY;
                    
                    // Gun base
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(handX, handY - 8, 30, 16);
                    
                    // Gun barrel
                    this.ctx.fillStyle = '#555';
                    this.ctx.fillRect(handX + 30, handY - 5, 20, 10);
                    
                    // Muzzle
                    this.ctx.fillStyle = '#222';
                    this.ctx.fillRect(handX + 50, handY - 8, 3, 16);
                    
                    // Muzzle flash when shooting - adjusted to match the new fire rate
                    if (this.frameCount % 25 < 5 && this.player.shooting) {
                        this.ctx.fillStyle = `rgba(255, 200, 0, ${0.7 + 0.3 * Math.sin(this.frameCount)})`;
                        this.ctx.beginPath();
                        this.ctx.moveTo(handX + 53, handY);
                        this.ctx.lineTo(handX + 65, handY - 10);
                        this.ctx.lineTo(handX + 75, handY);
                        this.ctx.lineTo(handX + 65, handY + 10);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Glow effect
                        const gradient = this.ctx.createRadialGradient(
                            handX + 65, handY, 0,
                            handX + 65, handY, 20
                        );
                        gradient.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        this.ctx.fillStyle = gradient;
                        this.ctx.fillRect(handX + 53, handY - 15, 30, 30);
                    }
                }
                
                this.ctx.restore();
            }
            
            // Add new method to handle player animation state
            updatePlayerAnimation() {
                // Increment animation timer
                this.player.animTimer += 1;
                
                // Determine animation state
                if (this.player.jumping) {
                    this.player.state = 'jumping';
                    
                    // Jump animation bob effect
                    const jumpProgress = Math.min(1, Math.abs(this.player.velocityY) / 10);
                    this.player.bobOffset = -5 * jumpProgress;
                } else if (Math.abs(this.player.velocityX) > 0.5) {
                    this.player.state = 'running';
                    
                    // Running animation frames
                    this.player.animFrame = Math.floor(this.player.animTimer / 5) % this.player.runFrames;
                    
                    // Running bob motion
                    this.player.bobOffset = Math.sin(this.player.animTimer * 0.2) * 3;
                } else {
                    this.player.state = 'idle';
                    this.player.animFrame = 0;
                    this.player.bobOffset = Math.sin(this.player.animTimer * 0.05) * 2; // Subtle breathing effect
                }
                
                // Shooting animation - updated to match new fire rate
                if (this.hasPowerUp && this.frameCount % 25 === 0) {
                    // Quick arm raise animation when shooting
                    this.player.rightArmRaised = true;
                    setTimeout(() => {
                        this.player.rightArmRaised = false;
                    }, 200);
                }
            }
            
            // Add method to draw particles around power-ups
            drawPowerUpParticles(powerUp) {
                // Generate particles based on frameCount
                if (powerUp.particles === undefined) {
                    powerUp.particles = [];
                    for (let i = 0; i < 12; i++) {
                        this.addPowerUpParticle(powerUp);
                    }
                }
                
                // Update and draw particles
                for (let i = powerUp.particles.length - 1; i >= 0; i--) {
                    const particle = powerUp.particles[i];
                    
                    // Update particle position
                    particle.angle += particle.speed;
                    particle.distance = powerUp.radius * 1.8 + Math.sin(this.frameCount * 0.1 + i) * powerUp.radius * 0.5;
                    
                    // Calculate position
                    const x = Math.cos(particle.angle) * particle.distance;
                    const y = Math.sin(particle.angle) * particle.distance;
                    
                    // Draw particle
                    this.ctx.fillStyle = particle.color;
                    this.ctx.globalAlpha = 0.5 + 0.5 * Math.sin(this.frameCount * 0.1 + i * 0.5);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Reset global alpha
                    this.ctx.globalAlpha = 1;
                    
                    // Check if particle needs to be replaced
                    particle.life--;
                    if (particle.life <= 0) {
                        powerUp.particles.splice(i, 1);
                        this.addPowerUpParticle(powerUp);
                    }
                }
            }
            
            // Helper method to add a new power-up particle
            addPowerUpParticle(powerUp) {
                const particle = {
                    angle: Math.random() * Math.PI * 2,
                    distance: powerUp.radius * (1.5 + Math.random()),
                    speed: 0.02 + Math.random() * 0.03,
                    size: 1 + Math.random() * 3,
                    color: `hsl(${30 + Math.random() * 40}, 100%, 70%)`,
                    life: 60 + Math.random() * 60
                };
                
                if (!powerUp.particles) {
                    powerUp.particles = [];
                }
                
                powerUp.particles.push(particle);
            }
            
            // Add special handling for power-up particles in the createParticle method
            createParticle() {
                // Different types of particles: 0=firefly, 1=leaf, 2=dust, 3=power-up
                const type = Math.floor(Math.random() * 3);
                
                let particle = {
                    x: Math.random() * this.width,
                    y: Math.random() * this.groundY * 0.8,
                    size: 2 + Math.random() * 4,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 0.5,
                    type: type,
                    opacity: 0.6 + Math.random() * 0.4,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    lifetime: 100 + Math.random() * 200
                };
                
                // Type-specific properties
                if (type === 0) { // Firefly
                    particle.color = `hsl(60, 100%, ${70 + Math.random() * 30}%)`;
                    particle.blinkSpeed = 0.05 + Math.random() * 0.05;
                    particle.blinkPhase = Math.random() * Math.PI * 2;
                } else if (type === 1) { // Leaf
                    particle.color = `hsl(${80 + Math.random() * 40}, 80%, 40%)`;
                    particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                    particle.speedY = 0.3 + Math.random() * 0.5; // Leaves fall down
                } else if (type === 2) { // Dust
                    particle.color = `hsla(40, 70%, 80%, ${0.3 + Math.random() * 0.3})`;
                    particle.speedY = -0.1 - Math.random() * 0.3; // Dust rises
                } else if (type === 3) { // Power-up particle
                    particle.color = `hsl(${40 + Math.random() * 20}, 100%, 60%)`;
                    particle.blinkSpeed = 0.1 + Math.random() * 0.1;
                    particle.blinkPhase = Math.random() * Math.PI * 2;
                    // These are created manually, not through this method
                }
                
                this.particles.push(particle);
            }
            
            // Update drawUI method to show an impressive power-up status indicator
            drawUI() {
                // Lives
                for (let i = 0; i < this.lives; i++) {
                    this.ctx.fillStyle = '#f00';
                    this.ctx.beginPath();
                    this.ctx.arc(30 + i * 30, 30, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Score
                this.ctx.fillStyle = 'white';
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`Score: ${this.score}`, this.width - 20, 30);
                
                // Power-up status with enhanced visuals
                if (this.hasPowerUp) {
                    const powerUpTimePercent = this.powerUpTimeLeft / this.powerUpDuration;
                    const barWidth = 200 * powerUpTimePercent;
                    
                    // Power-up background
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(this.width/2 - 100, 20, 200, 20);
                    
                    // Power-up bar - pulsing gradient
                    const gradient = this.ctx.createLinearGradient(this.width/2 - 100, 0, this.width/2 - 100 + barWidth, 0);
                    const intensity = 0.7 + 0.3 * Math.sin(this.frameCount * 0.1);
                    
                    gradient.addColorStop(0, `rgba(255, ${200 * intensity}, 0, 1)`);
                    gradient.addColorStop(1, `rgba(255, ${100 * intensity}, 0, 0.7)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(this.width/2 - 100, 20, barWidth, 20);
                    
                    // Bar highlights
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + 0.2 * Math.sin(this.frameCount * 0.2)})`;
                    this.ctx.fillRect(this.width/2 - 100, 21, barWidth, 3);
                    
                    // Power-up text with glow
                    this.ctx.shadowColor = 'rgba(255, 200, 0, 0.8)';
                    this.ctx.shadowBlur = 5 + 5 * Math.sin(this.frameCount * 0.1);
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('POWER-UP', this.width/2, 35);
                    this.ctx.shadowBlur = 0;
                    
                    // Power-up icon with rotation
                    this.ctx.save();
                    this.ctx.translate(this.width/2 - 120, 30);
                    this.ctx.rotate(this.frameCount * 0.05);
                    
                    // Star icon
                    this.ctx.fillStyle = '#fd2';
                    this.ctx.beginPath();
                    this.drawStar(0, 0, 5, 10, 5);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
            }
            
            // Add special handling for power-up particles in the createParticle method
            createParticle() {
                // Different types of particles: 0=firefly, 1=leaf, 2=dust, 3=power-up
                const type = Math.floor(Math.random() * 3);
                
                let particle = {
                    x: Math.random() * this.width,
                    y: Math.random() * this.groundY * 0.8,
                    size: 2 + Math.random() * 4,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 0.5,
                    type: type,
                    opacity: 0.6 + Math.random() * 0.4,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    lifetime: 100 + Math.random() * 200
                };
                
                // Type-specific properties
                if (type === 0) { // Firefly
                    particle.color = `hsl(60, 100%, ${70 + Math.random() * 30}%)`;
                    particle.blinkSpeed = 0.05 + Math.random() * 0.05;
                    particle.blinkPhase = Math.random() * Math.PI * 2;
                } else if (type === 1) { // Leaf
                    particle.color = `hsl(${80 + Math.random() * 40}, 80%, 40%)`;
                    particle.rotationSpeed = (Math.random() - 0.5) * 0.2;
                    particle.speedY = 0.3 + Math.random() * 0.5; // Leaves fall down
                } else if (type === 2) { // Dust
                    particle.color = `hsla(40, 70%, 80%, ${0.3 + Math.random() * 0.3})`;
                    particle.speedY = -0.1 - Math.random() * 0.3; // Dust rises
                } else if (type === 3) { // Power-up particle
                    particle.color = `hsl(${40 + Math.random() * 20}, 100%, 60%)`;
                    particle.blinkSpeed = 0.1 + Math.random() * 0.1;
                    particle.blinkPhase = Math.random() * Math.PI * 2;
                    // These are created manually, not through this method
                }
                
                this.particles.push(particle);
            }
            
            // Add new method to create a more impressive power-up collection effect
            collectPowerUp() {
                // Find a power-up that collides with the player
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    const dx = this.player.x - powerUp.x;
                    const dy = this.player.y - powerUp.height/2 - powerUp.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.player.width/2 + powerUp.radius) {
                        // Remove the power-up
                        this.powerUps.splice(i, 1);
                        
                        // Start transformation animation
                        this.transforming = true;
                        this.transformFrame = 0;
                        
                        // Power-up sound with special effect (play multiple times for intensity)
                        this.playSound('powerUp');
                        setTimeout(() => this.playSound('powerUp'), 200);
                        setTimeout(() => this.playSound('powerUp'), 400);
                        
                        // Create power-up collection effect at the player's position
                        this.createTransformationEffect();
                        
                        // Add score
                        this.addScore(50);
                        
                        // Update UI
                        this.updateUI();
                        
                        // Break after collecting one power-up
                        break;
                    }
                }
            }
            
            // Create a spectacular transformation effect
            createTransformationEffect() {
                // Create explosion particles for the transformation
                if (!this.transformParticles) {
                    this.transformParticles = [];
                }
                
                // Clear any existing particles
                this.transformParticles = [];
                
                // Add a burst of particles in a circular pattern
                const particleCount = 50;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 2 + Math.random() * 6;
                    const distance = 30 + Math.random() * 100;
                    
                    this.transformParticles.push({
                        x: 0, // Relative to player
                        y: 0,
                        targetX: Math.cos(angle) * distance,
                        targetY: Math.sin(angle) * distance,
                        currentDist: 0,
                        maxDist: distance,
                        speed: speed,
                        size: 4 + Math.random() * 8,
                        color: `hsl(${30 + Math.random() * 30}, 100%, 60%)`,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        type: Math.floor(Math.random() * 3) // 0: circle, 1: star, 2: spark
                    });
                }
                
                // Add energy rings
                for (let i = 0; i < 5; i++) {
                    this.transformParticles.push({
                        x: 0,
                        y: 0,
                        ring: true,
                        delay: i * 5,
                        radius: 10,
                        maxRadius: 150,
                        speed: 2 + i * 0.5,
                        thickness: 5,
                        color: `hsl(${40 + i * 10}, 100%, 60%)`
                    });
                }
                
                // Create lightning bolts
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    this.transformParticles.push({
                        x: 0,
                        y: 0,
                        lightning: true,
                        angle: angle,
                        length: 70 + Math.random() * 50,
                        segments: 5 + Math.floor(Math.random() * 3),
                        width: 3 + Math.random() * 2,
                        color: `hsl(${40 + Math.random() * 30}, 100%, 70%)`,
                        duration: 30 + Math.random() * 20,
                        currentFrame: 0
                    });
                }
            }
            
            // Add to the draw method to handle the power-up transformation flash
            draw() {
                // Clear the canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Power-up collection flash effect
                if (this.powerUpFlash > 0) {
                    const flashAlpha = this.powerUpFlash / 30 * 0.3; // fade from 0.3 to 0
                    this.ctx.fillStyle = `rgba(255, 255, 150, ${flashAlpha})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.powerUpFlash--;
                }
                
                // Background color flash during transformation
                if (this.transforming) {
                    // Pulsing flash during transformation
                    const flashIntensity = 0.2 + 0.1 * Math.sin(this.transformFrame * 0.2);
                    this.ctx.fillStyle = `rgba(255, 220, 150, ${flashIntensity})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                }
                
                // Draw background
                this.drawBackground();
                
                // Draw ground and objects
                this.drawGroundAndObjects();
                
                // Draw player
                this.drawPlayer();
                
                // Draw UI
                this.drawUI();
                
                // Draw game over screen if needed
                if (this.gameOver) {
                    this.drawGameOver();
                }
            }
            
            // Update the update method to handle the transformation animation
            update(timestamp) {
                // Calculate delta time
                let deltaTime = 0;
                if (this.lastUpdateTime) {
                    deltaTime = timestamp - this.lastUpdateTime;
                }
                this.lastUpdateTime = timestamp;
                
                this.frameCount++;
                
                // Don't update if game is over
                if (this.gameOver) {
                    return;
                }
                
                // Handle transformation animation
                if (this.transforming) {
                    this.transformFrame++;
                    
                    // Calculate animation progress (0 to 1)
                    const progress = this.transformFrame / this.transformMaxFrames;
                    
                    // Scale and rotation effects
                    this.transformScale = 1 + Math.sin(progress * Math.PI) * 0.3;
                    this.transformRotation = Math.sin(progress * Math.PI * 4) * 0.1;
                    
                    // Update transform particles
                    if (this.transformParticles) {
                        // Update regular particles
                        for (let i = 0; i < this.transformParticles.length; i++) {
                            const particle = this.transformParticles[i];
                            
                            // Ring particles
                            if (particle.ring) {
                                if (this.transformFrame > particle.delay) {
                                    particle.radius += particle.speed;
                                    
                                    // Remove when expanded to max size
                                    if (particle.radius > particle.maxRadius) {
                                        particle.radius = particle.maxRadius;
                                    }
                                }
                            }
                            // Lightning particles
                            else if (particle.lightning) {
                                particle.currentFrame++;
                                
                                // Regenerate lightning every few frames for flickering effect
                                if (particle.currentFrame % 5 === 0) {
                                    particle.segments = 5 + Math.floor(Math.random() * 3);
                                }
                                
                                // Remove when past duration
                                if (particle.currentFrame > particle.duration) {
                                    this.transformParticles.splice(i, 1);
                                    i--;
                                }
                            }
                            // Regular particles
                            else {
                                // Move particle toward target position
                                particle.currentDist += particle.speed;
                                if (particle.currentDist > particle.maxDist) {
                                    particle.currentDist = particle.maxDist;
                                }
                                
                                // Calculate position along path
                                const ratio = particle.currentDist / particle.maxDist;
                                particle.x = particle.targetX * ratio;
                                particle.y = particle.targetY * ratio;
                                
                                // Rotate particle
                                particle.rotation += particle.rotationSpeed;
                                
                                // Apply gravity curve to ypos
                                particle.y += 20 * ratio * ratio;
                            }
                        }
                    }
                    
                    // When transformation is complete
                    if (this.transformFrame >= this.transformMaxFrames) {
                        this.transforming = false;
                        this.transformScale = 1;
                        this.transformRotation = 0;
                        
                        // Apply power-up effect now that transformation is complete
                        this.hasPowerUp = true;
                        this.powerUpTimeLeft = this.powerUpDuration;
                        
                        // Flash effect
                        this.powerUpFlash = 30;
                    }
                }
                
                // Pause regular updates during transformation
                if (!this.transforming) {
                    // Update player
                    this.updatePlayer(deltaTime);
                    
                    // Update objects
                    this.updateObjects(deltaTime);
                    
                    // Generate new objects
                    this.generateObjects();
                    
                    // Check collisions
                    this.checkCollisions();
                    
                    // Update power-up effect
                    if (this.hasPowerUp) {
                        this.powerUpTimeLeft--;
                        
                        // Power-up expires
                        if (this.powerUpTimeLeft <= 0) {
                            this.hasPowerUp = false;
                        }
                    }
                }
                
                // Update power-up collection effects
                if (this.powerUpEffects) {
                    for (let i = this.powerUpEffects.length - 1; i >= 0; i--) {
                        const effect = this.powerUpEffects[i];
                        
                        // Update position
                        effect.x += effect.vx;
                        effect.vy += 0.2; // Gravity
                        effect.y += effect.vy;
                        
                        // Update life
                        effect.life--;
                        
                        // Remove dead particles
                        if (effect.life <= 0) {
                            this.powerUpEffects.splice(i, 1);
                        }
                    }
                }
                
                // Schedule the next update
                requestAnimationFrame(this.update.bind(this));
            }
        }
    </script>
</body>
</html> 